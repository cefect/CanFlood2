# -*- coding: utf-8 -*-
"""
/***************************************************************************
 canfloodDialog
                                 A QGIS plugin
 Open source flood risk modelling toolbox for Canada v2
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-03-04
        git sha              : $Format:%H$
        copyright            : (C) 2025 by NRCan
        email                : bryant.seth@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#===============================================================================
# IMPORTS-------------
#===============================================================================


import os, sys, re, gc, shutil, webbrowser, copy, hashlib, time
import sqlite3
import pandas as pd
import numpy as np

#PyQt
from PyQt5 import uic, QtWidgets
from PyQt5.QtWidgets import (
    QAction, QFileDialog, QListWidget, QTableWidgetItem, QDoubleSpinBox,
    QLabel, QPushButton, QProgressBar
    )

 

#qgis
from qgis.gui import QgsMapLayerComboBox, QgisInterface
from qgis.core import (
    QgsProject, QgsVectorLayer, QgsRasterLayer, QgsMapLayerProxyModel,
    QgsWkbTypes, QgsMapLayer, QgsLogger,
    )


#matplotlib
import matplotlib.pyplot as plt
import matplotlib


from .hp.plug import (
    plugLogger, bind_layersListWidget, get_layer_info_from_combobox, bind_tableWidget,
    bind_MapLayerComboBox, bind_simpleListWidget
    )

from .hp.basic import view_web_df as view
from .hp.qt import set_widget_value
from .hp.sql import get_table_names
from .hp.Q import get_unique_layer_by_name
from .hp.plt import get_figure_hash, PltWindow
 

from .parameters import (
    home_dir, plugin_dir,  project_db_schema_d,
    fileDialog_filter_str, hazDB_schema_d, hazDB_meta_template_fp,
    projDB_schema_modelTables_d, consequence_category_d,
    eventMeta_control_d)
import canflood2.parameters as parameters

from .assertions import (
    assert_projDB_fp, assert_projDB_conn, assert_hazDB_conn, assert_hazDB_fp, 
    assert_df_matches_projDB_schema, assert_series_match
    )

from .core import _get_proj_meta_d, Model
from .db_tools import df_to_sql, get_template_df, sql_to_df
from .dialog_model import Model_config_dialog


#tutorial dev loaders
from .tutorials.tutorial_data_builder import tutorial_data_lib, tutorial_fancy_names_d, widget_values_lib

#===============================================================================
# load UI and resources
#===============================================================================

#append the path (resources_rc workaround)
resources_module_fp = os.path.join(plugin_dir, 'resources.py')
assert os.path.exists(resources_module_fp), resources_module_fp 
if not os.path.dirname(resources_module_fp) in sys.path:
    sys.path.append(os.path.dirname(resources_module_fp))

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
ui_fp = os.path.join(os.path.dirname(__file__), 'canflood2_dialog_main.ui')
assert os.path.exists(ui_fp), f'UI file not found: {ui_fp}'
FORM_CLASS, _ = uic.loadUiType(ui_fp, resource_suffix='') #Unknown C++ class: Qgis




#===============================================================================
# Dialog class------------------
#===============================================================================

class Main_dialog_projDB(object):
    """methods for dealing with the project database"""
    def get_projDB_fp(self):
        """get the project database file path and do some formatting and checks"""
        fp = self.lineEdit_PS_projDB_fp.text()
        if fp=='':
            fp = None
        
        if not fp is None:
            assert isinstance(fp, str)
            assert os.path.exists(fp), f'bad filepath for projDB: {fp}'
            
        return fp
        

    def projDB_get_tables(self, table_names, projDB_fp=None, result_as_dict=False, template_prefix=None):
        """Convenience wrapper to get multiple tables as DataFrames.
    
        Parameters:
        *table_names: Variable number of table names (str) to fetch.
        projDB_fp: Optional; path to the project database file. If None, it will use the value from self.lineEdit_PS_projDB_fp.text().
        result_as_dict: Optional; if True, returns a dictionary {name: df} instead of a tuple.
    
        Returns:
        If a single table name is passed, returns a DataFrame; otherwise, returns a tuple of DataFrames in the same order as table_names or a dictionary {name: df} if result_as_dict is True.
        """
        assert isinstance(table_names, list)
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
        
        assert isinstance(projDB_fp, str)
        assert os.path.exists(projDB_fp)
    
        with sqlite3.connect(projDB_fp) as conn:
            #assert_projDB_conn(conn)
 
            dfs = {name: sql_to_df(name, conn, template_prefix=template_prefix) for name in table_names}
    
        if result_as_dict:
            return dfs
        else:
            return list(dfs.values()) 
             

    

    def projDB_set_tables(self, df_d, projDB_fp=None, conn=None, logger=None, **kwargs):
        """Convenience wrapper to set multiple tables from DataFrames.
    
        Parameters:
        df_d: dict
            Dictionary of DataFrames to set in the project database.
        projDB_fp: Optional; path to the project database file. If None, it will use the value from self.lineEdit_PS_projDB_fp.text().
        conn: Optional; SQLite connection object. If None, a new connection will be created.
        """
        
        if logger is None: logger=self.logger
        log = logger.getChild('projDB_set_tables')
        
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
    

    
        #assert_projDB_fp(projDB_fp)
    
        # Check if conn is provided, if not, create a new connection
        close_conn = False
        if conn is None:
            conn = sqlite3.connect(projDB_fp)
            close_conn = True
    
        try:
            for k, df in df_d.items():
                df_to_sql(df, k, conn,  **kwargs)
                log.debug(f'    wrote table \'{k}\' w/ {df.shape}')
 #==============================================================================
 #                try:
 #                    #handling schema checks in the df_to_sql function
 # 
 #   #============================================================================
 #   #                  if k in project_db_schema_d.keys():
 #   #                      """this test happens before we re-cast the types and indicies"""
 #   #                      
 #   #                      assert_df_matches_projDB_schema(k, df, check_dtypes=False)
 #   # 
 #   #                  elif k.startswith('model_'):
 #   #                      pass
 #   #  
 #   #                  elif k.startswith('vfunc_'):
 #   #                      pass
 #   #  
 #   #                  else:
 #   #                      raise KeyError(f'bad table name: {k}')
 #   #============================================================================
 #    
 #                    df_to_sql(df, k, conn, if_exists='replace', **kwargs)
 #                    log.debug(f'    wrote table \'{k}\' w/ {df.shape}')
 # 
 #                except Exception as e:
 #                    raise IOError(f'failed to set table \'{k}\' to project database:\n     {e}') from None
 #==============================================================================
        finally:
            #assert_projDB_conn(conn)
            if close_conn:
                conn.close()
    
        log.debug(f'updated {list(df_d.keys())} tables in project database at\n    {projDB_fp}')

                
    def projDB_drop_tables(self, *table_names, projDB_fp=None, logger=None):
        """Convenience wrapper to drop multiple tables from the project database.
    
        Parameters:
        *table_names: Variable number of table names (str) to drop.
        projDB_fp: Optional; path to the project database file. If None, it will use the value from self.lineEdit_PS_projDB_fp.text().
        """
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
        if logger is None: logger=self.logger
        log = logger.getChild('projDB_drop_tables')
    
        assert_projDB_fp(projDB_fp)
    
 

        with sqlite3.connect(projDB_fp) as conn:
            for name in table_names:
                assert name in get_table_names(conn), name
                conn.execute(f'DROP TABLE IF EXISTS [{name}]')
        
                # Check if the table still exists
                if name in get_table_names(conn):
                    raise RuntimeError(f'Failed to drop table: {name}')
        
        log.debug(f'dropped {len(table_names)} tables from project database\n    {table_names}')
        
    def projDB_get_table_names_all(self, projDB_fp=None):
        """Convenience wrapper to get all table names from the project database.
    
        Parameters:
        projDB_fp: Optional; path to the project database file. If None, it will use the value from self.lineEdit_PS_projDB_fp.text().
    
        Returns:
        List of table names in the project database.
        """
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
    
        with sqlite3.connect(projDB_fp) as conn:
 
            return get_table_names(conn)

 
        

    def update_model_index_dx(self, model, **kwargs):
        """update the model index table with the model"""
        dx = self.projDB_get_tables(['03_model_suite_index'])[0]
 
 
        #retrieve the parameters from teh models parameter table
        s = model.get_model_index_ser()
 
        

        # Update the dx DataFrame where the MultiIndex names match the model's category_code and modelid
        dx.loc[pd.IndexSlice[model.category_code, model.modelid], :] = s
        
        #recast types from template
        """necessary when we set a single row like the above"""
        dx = dx.astype(parameters.project_db_schema_d['03_model_suite_index'].dtypes.to_dict())
  
        
        """
        dx.dtypes
        dx.index.dtypes
        """
        #self.set_model_index_dx(dx, **kwargs)
        self.projDB_set_tables({'03_model_suite_index':dx}, **kwargs) 
        
 

class Main_dialog_dev(object):
    def _load_tutorial_to_ui(self):
        """load the tutorial data into the UI"""
        #=======================================================================
        # defaults
        #=======================================================================
        
        log = self.logger.getChild('_load_tutorial_to_ui')
        
        # Get the current project instance and its layer tree root
        project = QgsProject.instance()
        root = project.layerTreeRoot()


        
        #retrieve the fancy tutorial name from teh combo box
        tut_name_fancy = self.comboBox_tut_names.currentText()
        
        assert not tut_name_fancy == '', 'no tutorial selected'
        
        tutorial_name = {v:k for k,v in tutorial_fancy_names_d.items()}[tut_name_fancy]
        
        
        
        
        
        log.debug(f'loading tutorial \'{tutorial_name}\'')
        
 
        #=======================================================================
        # # Create the parent group for this tutorial
        #======================================================================= 
        tutorialGroup = root.findGroup(tutorial_name)
        if not tutorialGroup:
            tutorialGroup = root.addGroup(tutorial_name)
        
        
        #=======================================================================
        # set widget paramerters
        #=======================================================================
        """no... just load from the projDB"""
        #=======================================================================
        # widget_data_d = widget_values_lib[tutorial_name]['Main_dialog']
        # 
        # for widget_name, v in widget_data_d.items():
        #     widget = getattr(self, widget_name, None)
        #     if widget is not None:
        #         set_widget_value(widget, v)
        #=======================================================================
                
        #=======================================================================
        # load layers-----
        #=======================================================================
        """here we load from the tutorial file data onto the QgisProject
        loading the projDB will attempt to popuolate the ui by selecting from loaded layers"""
        data_d = tutorial_data_lib[tutorial_name]
        
        param_s = project_db_schema_d['02_project_parameters'].copy().set_index('varName')['widgetName']
        
        def add_layer(data_key, param_name, Constructor, set_widget=True):           

            try:
                if not data_key in data_d:
                    raise KeyError(f'failed to find data key \'{data_key}\'')
                #load the layer
                layer = Constructor(data_d[data_key], tutorial_name+'_'+data_key)
                
                # Check if the layer is valid before adding it to the project.
                if not layer.isValid():
                    raise IOError(f'failed to load layer \'{data_key}\'')
                    
                
                # Add the layer to the current QGIS project, which updates the canvas automatically.
                QgsProject.instance().addMapLayer(layer, False)
                
                tutorialGroup.addLayer(layer)
                
                #check this was loaded to the project
                assert get_unique_layer_by_name(layer.name()) is not None, f'failed to load layer \'{layer.name()}\''
                
                
                #set the widget
                if set_widget:
                    widget = getattr(self, param_s[param_name])
                    set_widget_value(widget, layer)
                
                #wrap            
                log.debug(f'added layer \'{layer.name()}\' to project')
            except Exception as e:
                log.error(f'failed to add layer \'{data_key}\' for {tutorial_name} w/\n    {e}')
            
        
        #=======================================================================
        # from parametesr
        #=======================================================================
        """note... these layer names need to match what was set when teh projDB test was done
        see tests.data.tutorial_fixtures
        
        NOTE: order matters for legend
        
        
        TODO: add styles
        """
        vlayConstructor = lambda x,y:QgsVectorLayer(x,y, 'ogr')
        
        
        #aoi
        add_layer('aoi', 'aoi_vlay_name', vlayConstructor)
        
        #FINV
        add_layer('finv', 'finv_rlay_name', vlayConstructor,
                  set_widget=False, #finv lives on the Model COnfig dialog
                  )
 
        #DEM
        add_layer('dem', 'dem_rlay_name', QgsRasterLayer)
        
 
        #=======================================================================
        # layers: hazard----------
        #=======================================================================
        #clear the selection
        self.listView_HZ_hrlay.clear_checks()
 
        hazardGroupName = "hazard event rasters"
        hazardGroup = tutorialGroup.findGroup(hazardGroupName)
        if not hazardGroup:
            hazardGroup = tutorialGroup.addGroup(hazardGroupName)
    
    
        haz_rlay_d = dict()
        for ari, fp in data_d['haz'].items():
            log.debug(f'adding hazard raster \'{ari}\'={os.path.basename(fp)}')
            
            #load to project
            layer = QgsRasterLayer(fp, os.path.basename(fp).split('.')[0])
            result = project.addMapLayer(layer,
                                False, #dont add it ot the legend
                                )
            
            assert not result is None
            
            hazardGroup.addLayer(layer)
            
            haz_rlay_d[layer.name()] = layer
            
        hazardGroup.setExpanded(False) #collapse the group
            
        
        log.debug(f'added {len(haz_rlay_d)} hazard rasters')
        
        #update the meta table widget
        """not strictly necessary for the projDB, but nice for the user to see"""
        self.listView_HZ_hrlay.populate_layers()
        try:
            self.listView_HZ_hrlay.check_byName([layer.name() for layer in haz_rlay_d.values()])
        except Exception as e:
            """this can happen if the user pushes the button twice"""
            log.error(f'failed to check layers w/ {e}')
            
        #=======================================================================
        # model specific data
        #=======================================================================
 
        
        #=======================================================================
        # load projDB------
        #=======================================================================
        #retrieve
        if 'projDB' in data_d:
            
            projDB_fp = data_d['projDB']
            #copy over the project database file
            """dont want the user to make changes to the plugin version"""
            projDB_fp = shutil.copyfile(projDB_fp, os.path.join(home_dir, os.path.basename(projDB_fp)))
            log.debug(f'copied project database to\n    {projDB_fp}')
            
            #set in dialog
            """same thing that happens when pushButton_PS_projDB_load is pushed"""
            self.lineEdit_PS_projDB_fp.setText(projDB_fp) 
            
            #run load routines
            self._load_projDB_to_ui(projDB_fp=projDB_fp)
            
            #activate the save button
            self.pushButton_save.setEnabled(True)
        
        else:
            log.warning('no projDB data found')
            
        log.push(f'loaded tutorial \'{tutorial_name}\'')
        
 
    
    
class Main_dialog_haz(object):
    """oragnizing hazard dialog functions here"""
    
    def _connect_slots_haz(self, log):
        #=======================================================================
        # Hazard Scenario Database File
        #=======================================================================

        def import_hazard_database_ui():
            filename, _ = QFileDialog.getOpenFileName(
                self,  # Parent widget (your dialog)
                "Open hazard database (sqlite) file",  # Dialog title
                home_dir,  # Initial directory (optional, use current working dir by default)
                "sqlite database files (*.db)"  # Example file filters
                )
            if filename:
                self._import_hazDB(filename)
            else:
                log.warning(f'no file selected')
 
                
        self.pushButton_HZ_hazDB_import.clicked.connect(import_hazard_database_ui)
        

        
        
        
        #=======================================================================
        # #Hazard Event Rasters
        #=======================================================================
        #setup the list widget and add some special methods
        lv = self.listView_HZ_hrlay 
        bind_layersListWidget(lv, log, iface=self.iface,layerType=QgsMapLayer.RasterLayer)
        
        #connect standard hazars selection buttons
        self.pushButton_HZ_hrlay_selectAll.clicked.connect(lv.check_all)
        self.pushButton_HZ_hrlay_selectVis.clicked.connect(lv.select_visible)
        self.pushButton_HZ_hrlay_canvas.clicked.connect(lv.select_canvas)
        self.pushButton_HZ_hrlay_clear.clicked.connect(lv.clear_checks)
        self.pushButton_HZ_refresh.clicked.connect(lambda x: lv.populate_layers())
        
        #TODO: add a button to select all layers matching some string (e.g., 'haz')
        
        lv.populate_layers() #do an intial popluation.
        
        #bind some methods to the tableWidget_HZ_eventMeta
        bind_tableWidget(self.tableWidget_HZ_eventMeta, self.logger, iface=self.iface,
                         widget_type_d=eventMeta_control_d,
                         )
        

            
        #=======================================================================
        # populating
        #=======================================================================
        self.pushButton_HZ_populate_clear.clicked.connect(
            self.tableWidget_HZ_eventMeta.clear_tableWidget
            )
        
        self.pushButton_HZ_hrlay_load.clicked.connect(self.load_selected_rasters_to_eventMeta_widget)
        
            #connect loading into the event metadata view
    def load_selected_rasters_to_eventMeta_widget(self):
 
        #retrieve the selected layers from teh above table
        layers_d = self.listView_HZ_hrlay.get_selected_layers()
        
        #use the layer names and the eventMeta_df_template to build a new dataframe
        eventMeta_df = hazDB_schema_d['05_haz_events'].copy()
        eventMeta_df['event_name'] = layers_d.keys()
        eventMeta_df['layer_id'] = [layer.id() for layer in layers_d.values()]
        eventMeta_df['layer_fp'] = [layer.source() for layer in layers_d.values()]
        eventMeta_df['prob'] = 0.0 #probability]]    
        
        assert_df_matches_projDB_schema('05_haz_events', eventMeta_df)        
        
        #load this dataframe into the table widget
        self.tableWidget_HZ_eventMeta.set_df_to_QTableWidget_spinbox(eventMeta_df)
        
    
    def xxx_create_new_hazDB(self, fp, overwrite=True):
        """create a new hazard database file
        
        export?"""
        log = self.logger.getChild('_create_new_hazDB')
        
        #file check
        if os.path.exists(fp):
            log.warning(f'specified hazard database already exists overwrite={overwrite}')
            if overwrite:
                os.remove(fp)
            else:
                raise FileExistsError(f'specified hazard database already exists and overwrite is not set')
                
        
        log.debug(f'creating new hazard database at\n    {fp}')
        
        #=======================================================================
        # create the database tables
        #=======================================================================
        df_d = dict()
        table_name='04_haz_meta'
        df_d[table_name] = pd.read_csv(hazDB_meta_template_fp)
        
        
        table_name='05_haz_events'
        df_d[table_name] = hazDB_schema_d[table_name].copy()
        #===================================================================
        # build the database
        #===================================================================
        with sqlite3.connect(fp) as conn:
            #create the tables
            for table_name, df in df_d.items():
                df_to_sql(df, table_name, conn, if_exists='replace')
 
                
            #check the database
            assert_hazDB_conn(conn)
            
        log.info(f'created new hazard database at\n    {fp}')
        
        self._save_haz_ui_to_hazDB(hazDB_fp=fp)
        
        return
        
    def xxx_save_haz_ui_to_hazDB(self, *args, hazDB_fp=None, projDB_fp=None):
        """save the current UI state to the hazard database
        
        export button?"""
        #=======================================================================
        # defaults
        #=======================================================================
        log = self.logger.getChild('_save_haz_ui_to_hazDB')
        if hazDB_fp is None:
            hazDB_fp = self.lineEdit_HZ_hazDB_fp.text()
            
        if projDB_fp is None:
            projDB_fp = self.lineEdit_PS_projDB_fp.text()
            
        if hazDB_fp == '' or hazDB_fp is None:
            raise ValueError('no hazard database file path specified')
        
        assert_hazDB_fp(hazDB_fp)
        
        log.debug(f'saving UI to hazard database at\n    {hazDB_fp}')
        #=======================================================================
        # open and load
        #=======================================================================
        df_d=dict()
        with sqlite3.connect(hazDB_fp) as conn:
            
            #===================================================================
            # update hazard meta
            #===================================================================
            table_name='04_haz_meta'
            df_d[table_name] = sql_to_df(table_name, conn)
 
            
            d = self._get_ui_state_from_df_template(df_d[table_name])
            df_d[table_name]['value'] = pd.Series(d)
            
            #===================================================================
            # update the hazard events table
            #===================================================================
            table_name='05_haz_events'
            """always starting fresh"""
 
            
            #read the dataframe from the table widget
            df_raw = self.tableWidget_HZ_eventMeta.get_df_from_QTableWidget()
            if len(df_raw)>0:
                df_d[table_name] = df_raw.rename(
                    columns={v['label']:k for k,v in eventMeta_control_d.items()})
                
 
                #clean up the extraction
                df_d[table_name] = df_d[table_name].replace('', pd.NA).astype(hazDB_schema_d[table_name].dtypes.to_dict())
                
                #assert_eventMeta_df(df_d[table_name])
                
                            #warn on empties
                for columnName, col in df_d[table_name].items():
                    if columnName in ['metadata']:continue
                    if col.isna().any():
                        log.warning(f'empty values in column \'{columnName}\'')
                    
            else:
                log.warning(f'no hazard event data entered')
 
 
            #===================================================================
            # #write the tables
            #===================================================================
            for k, df in df_d.items():
                assert k in hazDB_schema_d.keys(), k
                df_to_sql(df, k, conn, if_exists='replace')
 
                log.debug(f'    updated hazDB table \'{k}\' w/ {df.shape}')
                
            assert_hazDB_conn(conn)
            
            #close the connection
        log.debug(f'finished saving UI to hazard database at\n    {hazDB_fp}')
        #=======================================================================
        # update the project database as well
        #=======================================================================
        """mirroring the hazard tables inside the project database
            gives us a more portalbe project database
            makes accessing the full table stack easier
            
        users can still load a different hazard database, then load this into the project database
        """
        if not (projDB_fp is None or projDB_fp == ''):
            log.debug(f'updating project database w/ hazard tables \n    {projDB_fp}')
            with sqlite3.connect(projDB_fp) as conn:
                for k, df in df_d.items():
                    assert k in project_db_schema_d.keys(), k
                    df_to_sql(df, k, conn, if_exists='replace')
 
                    log.debug(f'    updated projDB table \'{k}\' w/ {df.shape}')
                    
                assert_projDB_conn(conn)
        else:
            log.warning(f'no project database found... hazard tables not mirrored')
        
        #close sqlite

        log.push(f'UI state saved to hazards database')
            
        return
    
    def _import_hazDB(self, hazDB_fp, logger=None):
        """load the UI state from a hazard database file"""
        raise NotImplementedError('need to add the import logic')
        #=======================================================================
        # defautls
        #=======================================================================
        if logger is None: logger=self.logger
        log = logger.getChild('_load_hazDB')
        if hazDB_fp is None:
            hazDB_fp = self.get_hazDB_fp()
            
        log.info(f'loading from hazard database at\n    {hazDB_fp}')
        #=======================================================================
        # load the tables
        #=======================================================================
        haz_meta_df, haz_events_df = self._hazDB_get_tables('04_haz_meta', '05_haz_events', hazDB_fp=hazDB_fp)
        
        
        #set UI parameter state
        self._get_ui_state_from_df_template(haz_meta_df, logger=log)
        
        #set the event metadata widget
        self.tableWidget_HZ_eventMeta.set_df_to_QTableWidget_spinbox(haz_events_df)
        
        log.debug(f'finished loading from hazard database at\n    {hazDB_fp}')
            
            
    
    def _hazDB_get_tables(self, table_names, hazDB_fp=None):
        """Convenience wrapper to get multiple tables as DataFrames.
    
        Parameters:
        *table_names: Variable number of table names (str) to fetch.
 
        """
        if hazDB_fp is None:
            hazDB_fp = self.lineEdit_HZ_hazDB_fp.text()
        assert isinstance(table_names, (list, tuple)), type(table_names)
        
        assert_hazDB_fp(hazDB_fp)
        
        with sqlite3.connect(hazDB_fp) as conn:
            dfs = tuple(sql_to_df(name, conn) for name in table_names)
             
    
        return dfs
    
    
    def get_haz_meta_df(self):
        """build the meta_df from the ui state"""
        
        #load the template
        df  = hazDB_schema_d['04_haz_meta'].copy()        
 
        #use to retrieve ui values
        d = self._get_ui_state_from_df_template(df)
        df['value'] = pd.Series(d)
        
        """
        view(df_template)
        """
        
        return df
    
    def get_haz_events_df(self, logger=None):
        #=======================================================================
        # defaults
        #=======================================================================
        if logger is None: logger=self.logger
        log = logger.getChild('get_haz_events_df')
        
        #=======================================================================
        # #read the dataframe from the table widget
        #=======================================================================
        df_raw = self.tableWidget_HZ_eventMeta.get_df_from_QTableWidget()
        
        log.debug(f'raw event metadata dataframe\n{df_raw.shape}')
        
        #=======================================================================
        # process
        #=======================================================================
        if len(df_raw)>0:
            df = df_raw.rename(
                columns={v['label']:k for k,v in eventMeta_control_d.items()})
            
        
            #clean up the extraction
            template_df = get_template_df('05_haz_events')
            
            df = df.replace('', pd.NA).astype(template_df.dtypes)
            

            for columnName, col in df.items():
                if columnName in ['metadata']:continue
                if col.isna().any():
                    log.warning(f'empty values in column \'{columnName}\'')
                
        else:
            log.warning(f'no hazard event data entered')
            df=None
            
        return df
    
    def get_haz_rlay_d(self):
        """get the selected hazard rasters
        
        here we simply retrieve teh selected rasters from the top panel
        these should be checked against the eventMeta table widget prior to use
        """
        try:
            return self.listView_HZ_hrlay.get_selected_layers()
    
        except Exception as e:
            raise IOError(f'failed to retrieve selected hazard rasters w/:\n    {e}')
    
 
            
            
            
            
class Main_dialog_modelSuite(object):
    """methods for dealing with the model suite and models""" 
    # reference container for identifying dynamically added widgets
    modelSuite_widget_type_d = {
        'label_mod_modelid': QLabel,
        'label_mod_asset': QLabel,
        'label_mod_consq': QLabel,
        'label_mod_status': QLabel,
        'progressBar_mod': QProgressBar,
        'pushButton_mod_run': QPushButton,
        'pushButton_mod_config': QPushButton,
        'pushButton_mod_plus': QPushButton,
        'pushButton_mod_minus': QPushButton
    }
    
    def _connect_slots_modelSuite(self, log):
        
        #inint the model config dialog
 
        
        self.pushButton_MS_clear.clicked.connect(self._clear_all_models)
        
        
        #=======================================================================
        # #create an initial model suite dialog in each category
        #=======================================================================
        def create_modelSuite_templates():
            #check that the model suites have been cleared
            assert len(self.model_index_d)==0, f'must clearn model suite before creating templates'
 
            
            # Loop through each group box, and load the model template into it.
 
            for category_code, d in consequence_category_d.items():
                gb = getattr(self, d['boxName'])
 
                # Create a new layout for the group box if it doesn't have one
                if gb.layout() is None:
                    gb.setLayout(QtWidgets.QVBoxLayout())
            
                # Add the loaded widget to the group box's layout
                self._add_model(gb.layout(), category_code, logger=log)
     
     
            log.debug("populated model suite")
            
        self.pushButton_MS_createTemplates.clicked.connect(create_modelSuite_templates)
        
        #=======================================================================
        # initilzie the model config
        #=======================================================================
        """initlizing this once when the parent starts
        this slows down the parent startup, 
        but should be better for user experience as this dialog is called multiple times
        need to add some logic for reseting the dialog each time it is called by the ocnfigure button
        """
        self.Model_config_dialog = Model_config_dialog(self.iface, parent=self, 
                                                       debug_logger=self.logger.debug_logger)
    

    def _add_model_widget(self, model, layout, 
                          logger=None):
        """add the widget for the model to the model suite tab"""
        #=======================================================================
        # defaults
        #=======================================================================
        if logger is None: logger=self.logger
        log = logger.getChild('_add_model_widget')
        
        
        
        modelid, category_code = model.modelid, model.category_code
        
        log.debug(f'adding model to category \'{category_code}\'')
        #=======================================================================
        # precheck
        #=======================================================================
        #check the layout is empty
        if layout.count() > 0:
            raise AssertionError(f'layout {layout.name()} is not empty')
        
        assert model.widget_d is None, 'model already has widgets'
 
        #=======================================================================
        # start template
        #=======================================================================
        widget = load_model_widget_template() #load the model template
        layout.addWidget(widget) #add it to the widget
        
        #loop through each of the widget elements and give them a reference
        """because we add these dynamically, we need a way to lookup by model id"""
        widget_d = dict()
        for name, widget_type in self.modelSuite_widget_type_d.items(): 
            
            # Recursive search: findChild is recursive by default in PyQt.
            child_widget = widget.findChild(widget_type, name)
            assert isinstance(child_widget, widget_type), f'failed to find widget: {name}'
            widget_d[name] = {'name':name, 'widget':child_widget}
        
        #=======================================================================
        # #attach to the model worker
        #=======================================================================
        """not sure about this.. might make cleaning up strange"""
        model.widget_d = widget_d
        model.widget_suite = widget
        #set labels
        self._update_model_widget_labels(model=model)
        
        #connect the buttons
        widget.pushButton_mod_run.clicked.connect(lambda:self._run_model(category_code, modelid))
        widget.pushButton_mod_config.clicked.connect(lambda:self._launch_config_ui(category_code, modelid))
        widget.pushButton_mod_minus.clicked.connect(lambda:self._remove_model(category_code, modelid))
        widget.pushButton_mod_plus.clicked.connect(lambda:self._add_model(layout, category_code))
        
        return model
    
    def _load_model(self, layout, model_index_s, projDB_fp=None, logger=None):
        """load a a model from the ProjDB onto the ui"""
        
        #=======================================================================
        # defaults
        #=======================================================================
        if logger is None: logger=self.logger
        log = logger.getChild('_load_model')
        
        if projDB_fp is None: projDB_fp = self.get_projDB_fp()
        
        log.info(f'loading model \'{model_index_s["name"]}\' to model suite')
        
        #=======================================================================
        # setup container
        #=======================================================================
        category_code, modelid  = model_index_s.name
        if not category_code in self.model_index_d:
            self.model_index_d[category_code] = dict()
        else:
            if modelid in self.model_index_d[category_code]:
                raise IOError(f'model \'{model_index_s["name"]}\' already loaded')
        
        #=======================================================================
        # init worker
        #=======================================================================        
        
        model = Model(parent=self,category_code=category_code, modelid=modelid, logger=self.logger)
        
        #=======================================================================
        # consistency checks  
        #=======================================================================
        """user can load a partial model
        jsut checking for minimum requirements:
            has a table_parameters
            has an entry in the model_index
        """
        
        #check the parameter table is present
        tables_d = model.get_table_names_all(projDB_fp=projDB_fp, result_as_dict=True)
        assert 'table_parameters' in tables_d, 'no parameters table found' 
        
        #check there are some paramters        
        assert not model.get_table_parameters()['value'].isna().all(), 'model parameters are empty'
        
        #check the modelid and category code match what is in the parameter table
        index_d = model.get_index_d()
        assert index_d['modelid']==modelid, 'modelid mismatch'
        assert index_d['category_code']==category_code, 'category_code mismatch'
        
        #check the model index
        model_s = model.get_model_index_ser()
        
        try:
            """some precision issues with result_ead in this check"""
            assert_series_match(model_s.drop('result_ead'), model_index_s.drop('result_ead'))
        except Exception as e:
            raise ValueError(f'failed to match model index series w/ error:\n    {e}')
        
        
        #=======================================================================
        # #setup the UI        
        #=======================================================================
        model = self._add_model_widget(model, layout, logger=log) 
 
        
        #=======================================================================
        # #add to the container
        #=======================================================================
 
        self.model_index_d[category_code][modelid] = model
        
        log.debug(f'added model \'{index_d}\'')
        
        return model
        
        
        
        

    def _add_model(self, layout, category_code,
                    logger=None,
                   projDB_fp=None,
                   check_projDB=False,
                   ):
        """start a model object, then add the template to the layout"""
        if logger is None: logger=self.logger.getChild('add_model')
        log = logger.getChild('add_model')
        if projDB_fp is None: projDB_fp = self.get_projDB_fp()
            
        assert not projDB_fp is None, 'must set a project database file before adding models'
        
        
        #=======================================================================
        # get index values
        #=======================================================================
        #retrieve the modelid
        if not category_code in self.model_index_d:
            self.model_index_d[category_code] = dict()
            
        modelid = len(self.model_index_d[category_code])
        
        modelName = f'{category_code}_{modelid}'
        
        log.debug(f'initiating model \'{modelName}\'')
        
        #=======================================================================
        # init worker
        #=======================================================================
        model = Model(
            parent=self,
            category_code=category_code, modelid=modelid, logger=self.logger)
        
        assert model.modelid==modelid, 'modelid mismatch'        
        index_d = model.get_index_d()
        
        
        #=======================================================================
        # index consistency checks
        #=======================================================================
        assert not modelid in self.model_index_d[category_code], f'modelid already in index'
        
        #check model is not in the index
        
        if check_projDB:
            """ this can happen when we load a project database with models already in it"""
            assert model.get_model_index_ser() is None, f'model already in index'
 
    
            # Check for latent model tables and log details if any are found
        
            latent_tables = model.get_tables_all()
            if len(latent_tables) > 0:
                error_message = f'Found {len(latent_tables)} latent model tables: {list(latent_tables.keys())}. Possible bad DB cleanup.'
                #log.error(error_message)
                raise AssertionError(error_message)

        
        
        #=======================================================================
        # init on project database
        #=======================================================================
        """only adding an entry to the index and the parameter table
        other tables are added during run"""
            
        log.debug(f'creating model parameter table for \'{modelName}\'')
        df_d = dict()
        with sqlite3.connect(projDB_fp) as conn:
            
            #===================================================================
            # #add the parameter table
            #===================================================================
            table_name = model.get_table_names(['table_parameters'])[0]
            df_d[table_name] = projDB_schema_modelTables_d['table_parameters'].copy()
            
            #add the indexers            
            for k,v in index_d.items():
                df_d[table_name].loc[df_d[table_name]['varName']==k, 'value'] = str(v)
 
            
            df_to_sql(df_d[table_name], table_name, conn, if_exists='replace', 
                      template_prefix=model.template_prefix_str)

            
        log.debug(f'created parameter table for model \'{modelName}\'')
 
        #===================================================================
        # #add entry to model index
        #===================================================================
        self.update_model_index_dx(model, projDB_fp=projDB_fp, logger=log)
 
            
        #check it
 
        if check_projDB:
            assert model.get_table_names_all()==[table_name], 'model tabels were not added correctly'
 
 
        
        #=======================================================================
        # #setup the UI        
        #=======================================================================
        model = self._add_model_widget(model, layout, logger=log)
        
 
 
        
        #=======================================================================
        # #add to the index
        #=======================================================================
 
        self.model_index_d[category_code][modelid] = model
        
        log.debug(f'added model \'{modelName}\' to category \'{category_code}\'')
        
        return model
        
    def _update_model_widget_labels(self, model=None):
        """update hte model suite widget witht he model labels"""
        
        if model is None:
            raise NotImplementedError('extract by index')
        
        #retrieve values from model index
        s = model.get_model_index_ser().fillna('')
 
        widget_d = model.widget_d
        
        widget_d['label_mod_modelid']['widget'].setText('%2d' % model.modelid)
        widget_d['label_mod_asset']['widget'].setText(s['asset_label'])
        widget_d['label_mod_consq']['widget'].setText(s['consq_label'])
        
        
        #=======================================================================
        # status
        #=======================================================================
        """status updates handled bymodel now"""
        #=======================================================================
        # widget_d['label_mod_status']['widget'].setText(s['status'])
        
        status = model.compute_status()
 
        if status == 'complete':
            widget_d['progressBar_mod']['widget'].setValue(100)
        else:
            widget_d['progressBar_mod']['widget'].setValue(0)

        
        
        
    def _launch_config_ui(self, category_code, modelid):
        """launch the configuration dialog"""
        log = self.logger.getChild('launch_config_ui')
        
        log.debug(f'user pushed model config for {category_code} {modelid}')
        #=======================================================================
        # retrival
        #=======================================================================
        #check ther eis a project database
        projDB_fp = self.get_projDB_fp()
        assert not projDB_fp is None, 'must set a project database file'
 

 
        #get this model
        model = self.model_index_d[category_code][modelid]
        
        dial = self.Model_config_dialog
        #check that the dialog is already closed
        assert not dial.isVisible(), 'dialog is already open!'
        
        
        log.info(f'launching model configuration dialog for {model.name}')
        #=======================================================================
        # #load the model into the dialog
        #=======================================================================
        dial.load_model(model, projDB_fp=projDB_fp)
 
        
        #launch teh dialog modally
        result = dial.exec_()
        
        #move teardown onto the child dialog for cleaner testing
        #dial.model=None #clear the model
        
    #===========================================================================
    # def _run_model(self, category_code, modelid):
    #     raise NotImplementedError('need to add the run logic')
    #===========================================================================
        
    def _remove_model(self, category_code, modelid, 
                      clear_projDB=True,
                      logger=None):
        """remove an individual model"""
        if logger is None: logger=self.logger
        log = logger.getChild(f'_remove_model_{category_code}_{modelid}')
        log.debug(f'clearing model {modelid} from category \'{category_code}\'')
        
        
        #retrieve the model
        model = self.model_index_d[category_code][modelid]
        
        
        #=======================================================================
        # #remove the widget
        #=======================================================================
        if model.widget_suite is not None:
            widget = model.widget_suite
 
 
            parent = widget.parentWidget()
            if parent is not None:
                layout = parent.layout()  # Get the parent's layout
                if layout is not None:
                    layout.removeWidget(widget)
            widget.setParent(None)   # Detach the widget from its parent
            widget.deleteLater()     # Schedule the widget for deletion           
            
            model.widget_suite = None
            
        #=======================================================================
        # #remove all the tables
        #=======================================================================
        if clear_projDB:
            #sometimes we dont want to touch the projectDatabase
            #model tables
            model_table_names_l = model.get_table_names_all()
            self.projDB_drop_tables(*model_table_names_l, logger=log)
            
            #remove entry from model index table
            dx = self.projDB_get_tables(['03_model_suite_index'] )[0].drop(index=(category_code, modelid))
 
            self.projDB_set_tables({'03_model_suite_index':dx}, logger=log)
        
            
        
        #=======================================================================
        # #exit the model helper instance
        #=======================================================================
        try:
            model.__exit__(None, None, None)
        except Exception as e:
            log.debug(f'Error during __exit__ cleanup: {e}')
            
        # Remove the helper instance from the dictionary.
        del self.model_index_d[category_code][modelid]
        
        # If no models remain in this category, you can remove the category key as well.
        if not self.model_index_d[category_code]:
            del self.model_index_d[category_code]
        
        
    def _clear_all_models(self, *args, clear_projDB=True, logger=None):
        """clear all the models"""
        if logger is None: logger=self.logger
        log = logger.getChild('_clear_all_models')
        cnt=0
        log.debug('clearing all models')
        
        #=======================================================================
        # #loop through each model and close it
        #=======================================================================
        #collect the keys so we dont work on the index
        keys_d = dict()
        for category_code, d in self.model_index_d.items():
            keys_d[category_code] = list(d.keys())
        
        #look through and delete by index
        for category_code, modelid_l in keys_d.items():
            for modelid in modelid_l:
                try:
                    self._remove_model(category_code, modelid, logger=log, clear_projDB=clear_projDB)
                except Exception as e:
                    raise IOError(f'failed to clear model {category_code}_{modelid}: {e}')  
                cnt+=1
            
            
        
        #reset the index dictionary
        self.model_index_d = dict()
        
        #reset the model index table
        """no... each model removes its own row"""
        #table_name='03_model_suite_index'
        #self.projDB_set_tables({table_name:project_db_schema_d[table_name].copy()})
        
        
        
        
        #check
        if clear_projDB:
            model_index_dx = self.projDB_get_tables(['03_model_suite_index'])[0]
            assert len(model_index_dx)==0, f'failed to clear models: {len(model_index_dx)}'
        
        #clear garbage
        gc.collect()
        

 
        log.info(f'cleared {cnt} models')
        
    def _load_model_tables(self, models_d, table_name, projDB_fp=None):
        """load the tables for the models"""
        log = self.logger.getChild('_load_model_tables')
        
        log.debug(f'loading \'{table_name}\' table for {len(models_d)} models')
        
        tables_d = dict()
        for name, model in models_d.items():
            tables_d[name] = model.get_tables([table_name], projDB_fp=projDB_fp)[0]
            
 
        return pd.concat(tables_d, names=['model_name'])
        

        

class Main_dialog_reporting(object):
    """methods for dealing with the reporting tab"""
    
    def _connect_slots_report(self, log):  
        
        #=======================================================================
        # browse button
        #=======================================================================
        def browse_working_directory():
            log.debug('browse_working_directory')
 

            directory = QFileDialog.getExistingDirectory(
                self,  # Parent widget (your dialog)
                "Select output directory",  # Dialog title
                home_dir  # Initial directory (optional, use current working dir by default)
            )

            if directory:
                self.lineEdit_R_outdir.setText(directory) 
   
                
        #connect the brows button to the file open dialog
        self.pushButton_R_browse.clicked.connect(browse_working_directory)
         
         
        #======================================================================
        # open buton
        #======================================================================
        def open_output_directory():
            log.debug('open_output_directory')
            directory = self.lineEdit_R_outdir.text()
            if os.path.exists(directory):
                os.startfile(directory)
            else:
                log.error(f'output directory not found: {directory}')
                 
        self.pushButton_R_open.clicked.connect(open_output_directory)
        
        #=======================================================================
        # results maps and figures------
        #=======================================================================
        
        #=======================================================================
        # model selection
        #=======================================================================
        bind_simpleListWidget(self.listView_R_modelSelection, logger=self.logger)
        
        self.pushButton_R_populate.clicked.connect(self._populate_results_model_selection)
        self.pushButton_R_selectAll.clicked.connect(lambda:self.listView_R_modelSelection.check_all())
        self.pushButton_R_clear.clicked.connect(lambda:self.listView_R_modelSelection.clear_checks())
        
        
        #=======================================================================
        # plotting functions
        #=======================================================================
        self.pushButton_R_riskCurve.clicked.connect(self._plot_risk_curve)
        
    def _populate_results_model_selection(self):
        """from the projDB, populate the model selection table"""
        
        #=======================================================================
        # defaults
        #=======================================================================
        log = self.logger.getChild('_populate_results_model_selection')
        
        #=======================================================================
        # load
        #=======================================================================
        model_index_dx = self.projDB_get_tables(['03_model_suite_index'])[0]
        
        model_df = model_index_dx.reset_index().loc[:, 
            ['name', 'category_code', 'modelid', 'asset_label', 'consq_label', 'result_ead']]
        
        log.debug(f'filtered model index table to {model_df.shape}')
        #=======================================================================
        # populate the table widget
        #=======================================================================
        """need something that shows the columns better...
        #collapse the frame into a list of strings
        string_s = model_df.apply(lambda row: ', '.join(row.astype(str)), axis=1)
        data_l = [f'model: {e}' for e in string_s.values.tolist()]"""
        
        #just using the names for now
        data_l = model_df['name'].to_list()
 
        
        self.listView_R_modelSelection.set_data(data_l)
        
        """
        view(model_df)
        """
        
    def _get_selected_models(self, projDB_fp=None):
        """return the models container for those selected in the listView"""
        
        #retrieve selected names from the widget
        names_l = self.listView_R_modelSelection.get_checked_items()
        
        #locate these in the model index
        dx = self.projDB_get_tables(['03_model_suite_index'], projDB_fp=projDB_fp)[0]
        
        bx = dx['name'].isin(names_l)
        
        assert bx.sum()==len(names_l), f'failed to find all selected models'
 
        
        selected_models_df = dx[bx].reset_index().loc[:, ['name', 'category_code', 'modelid']]
        
        #=======================================================================
        # retrieve these from the model container
        #=======================================================================
        cnt = 0
        d = dict()
        
        for i, row in selected_models_df.iterrows():
            
            """using a flat indexer"""
            d[row['name']] = self.model_index_d[row['category_code']][row['modelid']]
            cnt+=1
            
        assert cnt==len(names_l), f'failed to load all selected models'
        
        return d
            
        
            
        
    def _plot_risk_curve(self, *args):
        #=======================================================================
        # defaults
        #=======================================================================
        log = self.logger.getChild('_plot_risk_curve')
        projDB_fp = self.get_projDB_fp()
        
        plot_mode = self.comboBox_R_mode.currentText()
        #=======================================================================
        # load data
        #=======================================================================
        models_d = self._get_selected_models(projDB_fp=projDB_fp)
        
        #impacts summary
        impacts_summary_dx = self._load_model_tables(models_d, 'table_impacts_sum', projDB_fp=projDB_fp)        
        impacts_summary_dx = impacts_summary_dx.set_index(['AEP'], append=True).droplevel(1)
        
        #parameter values
        params_dx = self._load_model_tables(models_d, 'table_parameters', projDB_fp=projDB_fp)
        params_dx = params_dx.set_index(['varName'], append=True).droplevel(1)['value'].unstack('varName')
        
        result_ead_s = params_dx['result_ead']
        
        
        #join
        dx = impacts_summary_dx.unstack('AEP').droplevel(0, axis=1)
 
        
        dx['EAD'] = result_ead_s
        dx = dx.set_index('EAD', append=True)
        
        """
        view(params_dx)
        view(dx)
        """
        
        #=======================================================================
        # plot
        #=======================================================================
        log.info(f'plotting risk curve w/ {plot_mode} mode w/ {len(result_ead_s)} models')
        args = (dx,)
        skwargs = dict(logger=log)
        
        if plot_mode=='aggregate':
            raise NotImplementedError(f'plot_mode: {plot_mode}')
            fig = self._plot_risk_curve_aggregate(*args, **skwargs)
            
        elif plot_mode=='batch':
            fig = self._plot_risk_curve_batch(*args, **skwargs)
            
        else:
            raise NotImplementedError(f'plot_mode: {plot_mode}')
        
        #=======================================================================
        # launcht he plott dialog
        #=======================================================================
        
        self._fig_teardown(fig)
        
    def _plot_risk_curve_batch(self, dx,logger=None, 
                               line_style_d=None,
                               hatch_style_d=None,
                               ):
        """from the suite results, matrix subplot layout for each model"""
        
        #=======================================================================
        # defaults
        #=======================================================================
        if logger is None: logger=self.logger
        log = logger.getChild('_plot_risk_curve_batch')
        log.debug(f'plotting {dx.shape}')
        
        if line_style_d is None: 
            line_style_d = copy.deepcopy(parameters.plot_style_lib['risk_curve']['line'])
            
        if hatch_style_d is None:
            hatch_style_d = copy.deepcopy(parameters.plot_style_lib['risk_curve']['hatch'])
        
        #=======================================================================
        # setup figure
        #=======================================================================
 
        
        with matplotlib.rc_context(parameters.rcParams):
            fig = plt.figure()
            
            #add title
            fig.suptitle('Risk Curves')
            
            #add subplots, stacked vertically based on the number of models
            ax_ar = np.atleast_1d(fig.subplots(nrows=1, ncols=len(dx)))

            
            for i, ((model_name, EAD), row) in enumerate(dx.iterrows()):
                log.debug(f'plotting model \'{model_name}\' w/ EAD {EAD}')
                
                #===============================================================
                # get data
                #===============================================================
                ax = ax_ar[i]
                
                x_ar, y_ar = row.index.values.astype(float), row.values
                
                #===============================================================
                # add plot assets
                #===============================================================
                #add the line
                ax.plot(x_ar, y_ar, label=model_name, **line_style_d)
                
                #add the hatch
                ax.fill_betweenx(y_ar.astype(float), x1=x_ar, x2=0, **hatch_style_d)
                
                #===============================================================
                # post format
                #===============================================================
                """
                plt.show()
                """
                ax.set_title(f'{i}')
                
                ax.set_xlabel('AEP')
                ax.set_ylabel('EAD')
                
                ax.legend()
                
                #===============================================================
                # wrap
                #===============================================================
                log.debug(f'finished plotting model \'{model_name}\' w/ EAD {EAD}')
                
        #=======================================================================
        # wrap
        #=======================================================================
        log.info(f'finished plotting {dx.shape}')
        
        return fig
            
            
            
        
 
        
        
    def _plot_risk_curve_aggregate(self, impacts_summary_dx, result_ead_s):
        """plot the aggregate risk curve"""
        log = self.logger.getChild('_plot_risk_curve_aggregate')
        raise NotImplementedError()
        

        
        #return fig
    
    
    
    def _fig_teardown(self, fig,
                      out_dir=None,
                      logger=None,
                      ):
        """common method for handling a figure after it is generated"""
        
        #=======================================================================
        # derfaults
        #=======================================================================
        if logger is None: logger=self.logger
        log = logger.getChild('_fig_teardown')
        
        if out_dir is None:
            out_dir = self._get_out_dir()
        
        #=======================================================================
        # if ofp is None:
        #     hash_s =get_figure_hash(fig)
        #=======================================================================
            #ofp = os.path.join(self._get_out_dir(), 'risk_curve_%s.svg'%time.strftime('%Y%m%d_%H%M%S'))
            
        #=======================================================================
        # launch the dialog
        #=======================================================================
        window = PltWindow(fig, out_dir=out_dir, parent=self.iface.mainWindow())
        window.show()
        log.info('launched matplotlib window on %s' % fig._suptitle.get_text())
        window.activateWindow()
        window.raise_()
            
            
    def _get_out_dir(self):
        """get the output directory"""
        out_dir = self.lineEdit_R_outdir.text()
        if out_dir=='':
            out_dir = os.path.join(home_dir, 'output')
            self.lineEdit_R_outdir.setText(out_dir)
        os.makedirs(out_dir, exist_ok=True)
        return out_dir
    
            
        
        
        
        
        
        
 
    
class Main_dialog(Main_dialog_projDB, Main_dialog_haz, Main_dialog_modelSuite, 
                  Main_dialog_dev, Main_dialog_reporting,
                  QtWidgets.QDialog, FORM_CLASS):
    

    
 
    
    def __init__(self, parent=None,iface=None,debug_logger=None):
        """dialog for main CanFlood window
        
        
        Parameters
        ----------
        parent : QWidget
            parent widget
        iface : QgsInterface
            QGIS interface
            
        debug_logger : logging.Logger
            logger pytests
        """
        #not sure why the template passes parent here
        #super(Main_dialog, self).__init__(parent)
        super(Main_dialog, self).__init__()
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.parent=parent
        self.iface=iface 
        
        if not iface is None:
            assert 'QgisInterface' in str(type(iface)), f'bad iface type: {type(iface)}'

        
        self.model_index_d = dict() #for tracking the model instances
        #{category_code:{modelid:Model}}
        
        #setup logger
        self.logger = plugLogger(
            iface=self.iface, parent=self, statusQlab=self.progressText,debug_logger=debug_logger,
            log_nm='MD',
            )
        
        self.connect_slots()
        
        self.logger.debug('Main_dialog initialized')
        
    def connect_slots(self):
        """on launch of ui, populate and connect"""
 
        log = self.logger.getChild('connect_slots')
        log.debug('connecting slots')
        
        #=======================================================================
        # GEN=======================----------------
        #=======================================================================
        
        
        def close_dialog():
            self.logger.push(f'dialog reset')
            if not self.parent is None:
                self.parent.dlg=None
                self.parent.first_start=True #not ideal
            self.close()
        
        self.pushButton_close.clicked.connect(close_dialog)
        
        
        self.pushButton_save.clicked.connect(self._save_ui_to_projDB)
        
        #connect the help button to launch the ReadTheDocs page
        def launch_docs():
            log.info(f'launching documentation at\n    {parameters.docs_url}')
            try:
                webbrowser.open(parameters.docs_url)
            except Exception as e:
                log.error(f'failed to launch documentation at\n    {parameters.docs_url} w/ {e}')
        
        self.pushButton_help.clicked.connect(launch_docs)
        
        
        """not using 
        self.cancel_pushButton.clicked.connect(self.action_cancel_process)"""
        
        from canflood2 import __version__
        self.label_version.setText(f'v{__version__}')
        
        #QGIS_LOG_FILE
        self.pushButton_debugLog.clicked.connect(self.launch_QGIS_LOG_FILE)
        
        #=======================================================================
        # WELCOME======================--------------
        #=======================================================================
        #=======================================================================
        # tutorial data
        #=======================================================================
        
        
        #populate the comboBox
        self.comboBox_tut_names.addItems(
            [tutorial_fancy_names_d[k] for k in tutorial_data_lib.keys()]
            )
        #reverr to index -1
        self.comboBox_tut_names.setCurrentIndex(-1)
        
        #connect the runner button
        self.pushButton_tut_load.clicked.connect(self._load_tutorial_to_ui)
        
        #disable the pushbutton until the comboBox is set
        self.pushButton_tut_load.setEnabled(False)
        
        self.comboBox_tut_names.currentIndexChanged.connect(
            lambda : self.pushButton_tut_load.setEnabled(True))
        
        #=======================================================================
        # Project Setup tab========================-----------
        #=======================================================================
        
        #=======================================================================
        # project database file
        #=======================================================================
        
        def _new_projDB():
            """wrapper for the New Project Database button"""
 
            
            filename = None
            try:
                filename, _ = QFileDialog.getSaveFileName(
                    self,  # Parent widget (your dialog)
                    "Save project database (sqlite) file",  # Dialog title
                    home_dir,  # Initial directory (optional, use current working dir by default)
                    fileDialog_filter_str
                )
            except Exception as e:
                log.warning(f'error on file dialog: {e}')
                
            if filename:
                self.lineEdit_PS_projDB_fp.setText(filename)
                self._create_new_projDB(filename)
                self.pushButton_save.setEnabled(True)
                log.push(f'created new project database at\n    {filename}')
                
        self.pushButton_PS_projDB_new.clicked.connect(_new_projDB)
            
            
            
        def load_project_database_ui():
            log.debug('load_project_database_ui')
 
            filename, _ = QFileDialog.getOpenFileName(
                self,  # Parent widget (your dialog)
                "Open project database (sqlite) file",  # Dialog title
                home_dir,  # Initial directory (optional, use current working dir by default)
                fileDialog_filter_str  # Example file filters
                )
            if filename:
                self.lineEdit_PS_projDB_fp.setText(filename) 
                self._load_projDB_to_ui()
                
                #activate the save button
                self.pushButton_save.setEnabled(True)            
 
        self.pushButton_PS_projDB_load.clicked.connect(load_project_database_ui)
        

                
        
        
        #=======================================================================
        # MapLayerComboBox
        #=======================================================================
        bind_MapLayerComboBox(self.comboBox_aoi, iface=self.iface, layerType=QgsMapLayerProxyModel.PolygonLayer)

        bind_MapLayerComboBox(self.comboBox_dem, iface=self.iface, layerType=QgsMapLayerProxyModel.RasterLayer)
 
        
        #=======================================================================
        # Hazard scenario tab------------
        #=======================================================================
        self._connect_slots_haz(log)
        
        #=======================================================================
        # Model Suite---------
        #=======================================================================
        self._connect_slots_modelSuite(log)
        
        #=======================================================================
        # Reporting
        #=======================================================================
        self._connect_slots_report(log)
 
        
        #=======================================================================
        # wrap
        #=======================================================================
        log.debug('slots connected')
        



    
    def _create_new_projDB(self, fp, overwrite=True):
        """create a new project database file"""
        log = self.logger.getChild('_create_new_projDB')
        
        #file check
        if os.path.exists(fp):
            if overwrite:
                log.warning(f'specified project database already exists and will be overwritten')
                os.remove(fp)
            else:
                raise FileExistsError(f'specified project database already exists and overwrite is not set')
            
        df_d = dict()
        #=======================================================================
        # #build the project metadata
        #=======================================================================
        table_name='01_project_meta'
        d = _get_proj_meta_d(log)
        d.update(dict(function_name='_create_new_projDB', misc=''))
        
        
        df_d[table_name] = pd.DataFrame(d)
        
        assert_df_matches_projDB_schema(table_name, df_d[table_name])
        
        """
        table
        tabel
        """
        #=======================================================================
        # #build the project parameters
        #=======================================================================
        table_name='02_project_parameters'
        df_d[table_name] = project_db_schema_d[table_name].copy()
        
        #check the widget names match
        for widgetName in df_d[table_name]['widgetName']:
            assert hasattr(self, widgetName), f'widgetName not found: {widgetName}'
        
        assert_df_matches_projDB_schema(table_name, df_d[table_name])
        #=======================================================================
        # model suite template
        #=======================================================================
        """this will be over-written in _save_ui_to_projDB
        but we need it here to pass the check
        """
        table_name='03_model_suite_index'
        df_d[table_name] = project_db_schema_d[table_name].copy()
        
        assert_df_matches_projDB_schema(table_name, df_d[table_name])
        #=======================================================================
        # hazard tables
        #=======================================================================
        #hazard meta
        table_name='04_haz_meta'
        df_d[table_name] = project_db_schema_d[table_name].copy()
        
        assert_df_matches_projDB_schema(table_name, df_d[table_name])
        
        #others
        for k, v in hazDB_schema_d.items():
            if not k==table_name:
                assert isinstance(v, pd.DataFrame), k
                df_d[k] = v.copy()
                
                assert_df_matches_projDB_schema(k, df_d[k])
                
                
        #=======================================================================
        # remainers
        #=======================================================================
        for k, v in project_db_schema_d.items():
            if not k in df_d.keys():
                df_d[k] = v.copy()
                assert_df_matches_projDB_schema(k, df_d[k])
        
        #=======================================================================
        # #build/write to the database
        #=======================================================================
        log.debug(f'init project SQLite db at\n    {fp}')
        with sqlite3.connect(fp) as conn:
            for k, df in df_d.items():                
                df_to_sql(df, k, conn, if_exists='replace')
 
                
        #=======================================================================
        # check
        #=======================================================================
        try:
            assert_projDB_fp(fp)
        except Exception as e:
            raise IOError(f'after creating a new projDB, some checks are failing\n    {e}')
                
        log.info(f'created new project database w/ {len(df_d)} tables at\n    {fp}')
        
        #=======================================================================
        # wrap
        #=======================================================================
        """no.. lets wait til the user hits save
        self._save_ui_to_projDB(projDB_fp=fp)"""
        
        

    def _get_ui_state_from_df_template(self, df, logger=None):
        """take a dataframe with widget name columns and return a dictionary of widget values
        
        Parameters
        ----------
        df : pd.DataFrame
            columns: 'widgetName'
        """
        #=======================================================================
        # defautls
        #=======================================================================
        if logger is None: logger=self.logger
        log = logger.getChild('_get_ui_state_from_df_template')
        
        d = dict()
        for i, row in df.iterrows():
 
            widgetName = row['widgetName']
            #get the widget
            if not hasattr(self, widgetName):
                raise AttributeError(f'widgetName not found: {widgetName}')
            
            widget = getattr(self, widgetName)
            #retrieve value from widget
            if isinstance(widget, QtWidgets.QLineEdit):
                v = widget.text()
            elif isinstance(widget, QgsMapLayerComboBox):
                v, _ = get_layer_info_from_combobox(widget) #using names
            elif isinstance(widget, QtWidgets.QComboBox):
                v = widget.currentText()
            elif isinstance(widget, QtWidgets.QRadioButton):
                v = widget.isChecked()                
            else:
                raise NotImplementedError(f'widget type not implemented: {widget}')
            if (not v is None) and (v != ''):
                d[i] = v
            else:
                d[i] = np.nan
                
        #check the indicides match
 
        if not df.index.equals(pd.Series(d).index):
            raise ValueError("Indexes do not match")
        
        #=======================================================================
        # wrap
        #=======================================================================
        log.debug(f'set {len(d)} widget values from df')

        return d

    def _save_ui_to_projDB(self, *args, projDB_fp=None):
        """save the current UI state to the projDB
        
        the save button is on all tabs, so the user will expect this to dave all ui elements
        first we save the hazDB, then the project (which mirrors the hazDB)
        """
        #=======================================================================
        # defaults
        #=======================================================================
        log = self.logger.getChild('_save_ui_to_projDB')
        
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
            
        assert not projDB_fp is None, 'must set a project database file before saving'
        
 
 

        #=======================================================================
        # project database
        #=======================================================================        
        assert_projDB_fp(projDB_fp)
        log.debug(f'saving UI to project database at\n    {projDB_fp}')
        
        
        df_d=dict()
        with sqlite3.connect(projDB_fp) as conn:

            
            #===================================================================
            # update project metadata
            #===================================================================
            table_name='01_project_meta'
            d = _get_proj_meta_d(log)
            d.update(dict(function_name='_save_ui_to_projDB', misc=''))
            df_d[table_name] = pd.DataFrame(d)
            
            #===================================================================
            # #update the project parameters
            #===================================================================
            table_name='02_project_parameters'
            df_d[table_name] = sql_to_df(table_name, conn)
            #df_d[table_name] = pd.read_sql('SELECT * FROM [{}]'.format(table_name), conn)
            
            d = self._get_ui_state_from_df_template(df_d[table_name]) 
            
                        
            df_d[table_name]['value'] = pd.Series(d)
 
            
            
            #===================================================================
            # update the model suite index
            #===================================================================
            table_name='03_model_suite_index'
 
            blank_df = project_db_schema_d[table_name].copy()
 
            
 
            if len(self.model_index_d)>0:
                #d=dict()
                cnt=0
                log.debug(f'populating {table_name} w/ {len(self.model_index_d)} categories')
                for category_code, modelid_d in self.model_index_d.items():     
                    for modelid, wrkr in modelid_d.items():
                        
                        """this function is not optimized for bulk writing like this...."""
                        self.update_model_index_dx(wrkr) #update the model index with this worker
                        cnt+=1
 
                
                #check
                model_index_dx = self.projDB_get_tables(['03_model_suite_index'])[0]
                
                assert len(model_index_dx)==cnt, f'failed to save all models: {len(model_index_dx)}'
 
            else:
                log.debug(f'no models to save... storing template')
 
                df_d[table_name] = blank_df.copy()
            
            log.debug(f'finished setting {table_name}')
            #===================================================================
            # hazard tables
            #===================================================================
            table_name= '04_haz_meta'
            df_d[table_name] = self.get_haz_meta_df()
            
            table_name= '05_haz_events'
            haz_events_df = self.get_haz_events_df(logger=log)
            if not haz_events_df is None:
                df_d[table_name] = haz_events_df
 
            
            #===================================================================
            # write all the tables
            #===================================================================
            for k, df in df_d.items():
                assert k in project_db_schema_d.keys(), k
                df_to_sql(df, k, conn, if_exists='replace')
 
                log.debug(f'updated table \'{k}\' w/ {df.shape}')
                
        #close sqlite
        log.debug(f'updated {len(df_d)} tables in project database at\n    {projDB_fp}')
        log.push(f'UI state saved to project database')
            
        return
    
    def _load_projDB_to_ui(self, projDB_fp=None):
        """load an existing project database file
        
        this does not 'load' QgsMapLayers, but attempts to select them by name
        """
        log = self.logger.getChild('_load_projDB_to_ui')
        
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
 
 
        assert not projDB_fp is None or projDB_fp=='', 'no project database file path specified'
        log.debug(f'loading project database from\n    {projDB_fp}')
        
        
        assert_projDB_fp(projDB_fp, check_consistency=True)
 
        #=======================================================================
        # set the ui state from the project parameters
        #=======================================================================
        """selects dem and aoi (not hazard layers or finv)"""
        table_name='02_project_parameters'
        df_raw = self.projDB_get_tables([table_name], projDB_fp=projDB_fp)[0]
        s = df_raw.dropna(subset=['widgetName', 'value']).set_index('widgetName')['value']
 
        if len(s)>0:
            log.debug(f'loading {len(s)} project parameters')
            for widgetName, value in s.items():
     
                #get the widget
                try:
                    widget = getattr(self, widgetName)                
                    set_widget_value(widget, value)
                except Exception as e:
                    raise ValueError(f'failed to set widget \'{widgetName}\' to \'{value}\': \n    {e}')
                    log.error(f'failed to set widget \'{widgetName}\' to \'{value}\': \n'+\
                               f'    {e}\nprojDB may be out of sync')
                    
                #specials
                if widgetName=='radioButton_ELari':
                    if value=='1':
                        self.radioButton_ELari.setChecked(True)
                    elif value=='0':
                        self.radioButton_ELaep.setChecked(True)
                    else:
                        raise ValueError(f'bad value for radioButton_ELari: {value}')
                
        else:
            log.warning(f'no project parameters found in projDB')
        
 
        #=======================================================================
        # load hazard data
        #=======================================================================
        log.debug('loading hazard data')
        table_name='05_haz_events'
        haz_events_df = self.projDB_get_tables([table_name], projDB_fp=projDB_fp)[0]
        """
        view(haz_events_df)
        """
        #refresh the raster window
        self.listView_HZ_hrlay.populate_layers()
        
        #check that these events are loaded onto the project
        haz_rlay_d = dict()
        for _, row in haz_events_df.iterrows():
            layer_match = get_unique_layer_by_name(row['event_name'], layer_type=QgsRasterLayer)
            if layer_match is None:
                log.warning(f'failed to find matching raster for: {row["event_name"]}')
            
            haz_rlay_d[row['event_name']] = layer_match
        
        #select these
        """later, we assert that the selection matches the event meta table widget"""
        self.listView_HZ_hrlay.check_byName([layer.name() for layer in haz_rlay_d.values()])
        
        #load the event meta onto the widget
        self.tableWidget_HZ_eventMeta.set_df_to_QTableWidget_spinbox(haz_events_df)  
                
        #=======================================================================
        # set the model suite
        #=======================================================================
        log.debug('loading model suite')
        #clear the model suite
        if len(self.model_index_d)>0:
            self._clear_all_models(clear_projDB=False, logger=log)
        
        #load model index from the projDB
        model_index_dx = self.projDB_get_tables(['03_model_suite_index'], projDB_fp=projDB_fp)[0]
        
        if len(model_index_dx)>0:
            log.debug(f'loading {len(model_index_dx)} models')
            cnt=0
            for (category_code, modelid) , row in model_index_dx.iterrows():
 
                #get the groupbox
                params = consequence_category_d[category_code]
                gb = getattr(self, params['boxName'])                
                
                
                self._load_model(gb.layout(), row, projDB_fp=projDB_fp, logger=log) #LOAD a model!
                
                #check the modelid was added
                assert modelid in self.model_index_d[category_code], f'failed to add model {modelid}'
                cnt+=1
            
            log.info(f'loaded {cnt} models from project database')
                
        else:
            log.warning(f'no models found in projDB')
 
        #=======================================================================
        # wrap
        #=======================================================================
        log.push(f'loaded project from {os.path.basename(projDB_fp)}')
        
        return 
    
    
    
    def get_dem_vlay(self):
        """get the DEM layer"""
        rlay = self.comboBox_dem.currentLayer()
        if not rlay is None:
            assert isinstance(rlay, QgsRasterLayer)
             
        return rlay
    
    
    def launch_QGIS_LOG_FILE(self):
        """retrive the userse QGIS_LOG_FILE environment variable, 
        then launch with the default text application"""
        log = self.logger.getChild('launch_QGIS_LOG_FILE')
        log.debug('launching qgis debug log')
        
        #get the path
        QGIS_LOG_FILE_fp = os.getenv('QGIS_LOG_FILE')
        if not QGIS_LOG_FILE_fp is None:
            if os.path.exists(QGIS_LOG_FILE_fp):
                os.startfile(QGIS_LOG_FILE_fp)
            else:
                log.warning(f'QGIS_LOG_FILE file not found: {QGIS_LOG_FILE_fp}')
        else:
            log.warning(f'QGIS_LOG_FILE environment variable not set')
    

                

            
            

            
        
            
        
        
        
        
        
        
#===============================================================================
# helpers-----
#===============================================================================


        
 
    
    
# Load the widget from the .ui file
def load_model_widget_template(
    model_template_ui = os.path.join(os.path.dirname(__file__), 'canflood2_model_widget.ui'), 
    parent=None):
    """load the model widget template"""
    assert os.path.exists(model_template_ui), f'bad model_template_ui: {model_template_ui}'
    widget = QtWidgets.QWidget(parent)
    uic.loadUi(model_template_ui, widget)
    return widget

# Path to the model template UI file
def extract_gropubox_codes(input_string):
    """
    Extracts 'c1' and the remaining text from the input string.

    Parameters:
    input_string (str): The input string in the format '[c1] remaining text'.

    Returns:
    tuple: A tuple containing 'c1' and the remaining text.
    """
    pattern = r'\[(.*?)\]\s*(.*)'
    match = re.match(pattern, input_string)

    if match:
        c1 = match.group(1)
        remaining_text = match.group(2)
        return c1, remaining_text
    else:
        return None, None
        
