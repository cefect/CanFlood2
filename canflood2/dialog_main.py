# -*- coding: utf-8 -*-
"""
/***************************************************************************
 canfloodDialog
                                 A QGIS plugin
 Open source flood risk modelling toolbox for Canada v2
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-03-04
        git sha              : $Format:%H$
        copyright            : (C) 2025 by NRCan
        email                : bryant.seth@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
#===============================================================================
# IMPORTS-------------
#===============================================================================


import os, sys, re, gc, shutil
import sqlite3
import pandas as pd
import numpy as np

#PyQt
from PyQt5 import uic, QtWidgets
from PyQt5.QtWidgets import (
    QAction, QFileDialog, QListWidget, QTableWidgetItem, QDoubleSpinBox,
    QLabel, QPushButton, QProgressBar
    )

 

#qgis
from qgis.gui import QgsMapLayerComboBox
from qgis.core import (
    QgsProject, QgsVectorLayer, QgsRasterLayer, QgsMapLayerProxyModel,
    QgsWkbTypes, QgsMapLayer, QgsLogger,
    )

 

from .hp.plug import (
    plugLogger, bind_layersListWidget, get_layer_info_from_combobox, bind_tableWidget,
    bind_MapLayerComboBox
    )

from .hp.basic import view_web_df as view
from .hp.qt import set_widget_value
from .hp.sql import get_table_names
from .hp.Q import get_unique_layer_by_name
 

from .parameters import (
    home_dir, plugin_dir,  project_db_schema_d,
    fileDialog_filter_str, hazDB_schema_d, hazDB_meta_template_fp,
    projDB_schema_modelTables_d, consequence_category_d,
    eventMeta_control_d)

from .assertions import (
    assert_projDB_fp, assert_projDB_conn, assert_hazDB_conn, assert_hazDB_fp, 
    assert_df_matches_projDB_schema
    )

from .core import _get_proj_meta_d, Model
from .db_tools import df_to_sql, get_template_df, sql_to_df
from .dialog_model import Model_config_dialog


#tutorial dev loaders
from .tutorials.tutorial_data_builder import tutorial_data_lib, tutorial_fancy_names_d, widget_values_lib

#===============================================================================
# load UI and resources
#===============================================================================

#append the path (resources_rc workaround)
"""TODO: figure out if this is still needed or if there is a more elegant solution"""

resources_module_fp = os.path.join(plugin_dir, 'resources.py')
assert os.path.exists(resources_module_fp), resources_module_fp 
if not os.path.dirname(resources_module_fp) in sys.path:
    sys.path.append(os.path.dirname(resources_module_fp))

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
ui_fp = os.path.join(os.path.dirname(__file__), 'canflood2_dialog_main.ui')
assert os.path.exists(ui_fp), f'UI file not found: {ui_fp}'
FORM_CLASS, _ = uic.loadUiType(ui_fp, resource_suffix='') #Unknown C++ class: Qgis




#===============================================================================
# Dialog class
#===============================================================================

class Main_dialog_dev(object):
    def _load_tutorial_to_ui(self):
        """load the tutorial data into the UI"""
        log = self.logger.getChild('_load_tutorial_to_ui')
        
        #retrieve the fancy tutorial name from teh combo box
        tut_name_fancy = self.comboBox_tut_names.currentText()
        
        assert not tut_name_fancy == '', 'no tutorial selected'
        
        tutorial_name = {v:k for k,v in tutorial_fancy_names_d.items()}[tut_name_fancy]
        
        log.debug(f'loading tutorial \'{tutorial_name}\'')
        
        
        #=======================================================================
        # set widget paramerters
        #=======================================================================
        """no... just load from the projDB"""
        #=======================================================================
        # widget_data_d = widget_values_lib[tutorial_name]['Main_dialog']
        # 
        # for widget_name, v in widget_data_d.items():
        #     widget = getattr(self, widget_name, None)
        #     if widget is not None:
        #         set_widget_value(widget, v)
        #=======================================================================
                
        #=======================================================================
        # load layers-----
        #=======================================================================
        """here we load from the tutorial file data onto the QgisProject
        loading the projDB will attempt to popuolate the ui by selecting from loaded layers"""
        data_d = tutorial_data_lib[tutorial_name]
        
        param_s = project_db_schema_d['02_project_parameters'].copy().set_index('varName')['widgetName']
        
        def add_layer(data_key, param_name, Constructor):            

            
            #load the layer
            layer = Constructor(data_d[data_key], tutorial_name+'_'+data_key)
            
            # Check if the layer is valid before adding it to the project.
            if not layer.isValid():
                raise IOError(f'failed to load layer \'{data_key}\'')
                
            
            # Add the layer to the current QGIS project, which updates the canvas automatically.
            QgsProject.instance().addMapLayer(layer)
            
            #check this was loaded to the project
            assert get_unique_layer_by_name(layer.name()) is not None, f'failed to load layer \'{layer.name()}\''
            
            
            #set the widget
            widget = getattr(self, param_s[param_name])
            set_widget_value(widget, layer)
            
            #wrap            
            log.debug(f'added layer \'{layer.name()}\' to project')
            
        
        #=======================================================================
        # from parametesr
        #=======================================================================
        """note... these layer names need to match what was set when teh projDB test was done
        see tests.data.tutorial_fixtures
        """
        #aoi
        add_layer('aoi', 'aoi_vlay_name', lambda x,y:QgsVectorLayer(x,y, 'ogr'))
        #add_layer(QgsVectorLayer(data_d['aoi'], 'aoi_vlay', 'ogr'), 'aoi_vlay_name')
 
        #DEM
        add_layer('dem', 'dem_rlay_name', QgsRasterLayer)
        #add_layer(QgsRasterLayer(data_d['dem'], 'dem_rlay'), 'dem_rlay_name')
        
        #=======================================================================
        # #hazard rasters
        #=======================================================================
        haz_rlay_d = dict()
        for ari, fp in data_d['haz'].items():
            log.debug(f'adding hazard raster \'{ari}\'={os.path.basename(fp)}')
            
            #load to project
            layer = QgsRasterLayer(fp, os.path.basename(fp).split('.')[0])
            QgsProject.instance().addMapLayer(layer)
            
            haz_rlay_d[layer.name()] = layer
            
        
        log.debug(f'added {len(haz_rlay_d)} hazard rasters')
        
        #update the meta table widget
        """not strictly necessary for the projDB, but nice for the user to see"""
        self.listView_HZ_hrlay.populate_layers()
        self.listView_HZ_hrlay.check_byName([layer.name() for layer in haz_rlay_d.values()])
            
        #=======================================================================
        # model specific data
        #=======================================================================
 
        
        #=======================================================================
        # load projDB------
        #=======================================================================
        #retrieve
        projDB_fp = data_d['projDB']
        #copy over the project database file
        """dont want the user to make changes to the plugin version"""
        projDB_fp = shutil.copyfile(projDB_fp, os.path.join(home_dir, os.path.basename(projDB_fp)))
        log.debug(f'copied project database to\n    {projDB_fp}')
        
        #set in dialog
        """same thing that happens when pushButton_PS_projDB_load is pushed"""
        self.lineEdit_PS_projDB_fp.setText(projDB_fp) 
        
        #run load routines
        self._load_projDB_to_ui(projDB_fp=projDB_fp)
        
        #activate the save button
        self.pushButton_save.setEnabled(True)
        
 
    
    
class Main_dialog_haz(object):
    """oragnizing hazard dialog functions here"""
    
    def _connect_slots_haz(self, log):
        #=======================================================================
        # Hazard Scenario Database File
        #=======================================================================
 
        
        
        def import_hazard_database_ui():
            filename, _ = QFileDialog.getOpenFileName(
                self,  # Parent widget (your dialog)
                "Open hazard database (sqlite) file",  # Dialog title
                home_dir,  # Initial directory (optional, use current working dir by default)
                "sqlite database files (*.db)"  # Example file filters
                )
            if filename:
                self._import_hazDB(filename)
            else:
                log.warning(f'no file selected')
 
                
        self.pushButton_HZ_hazDB_import.clicked.connect(import_hazard_database_ui)
        

        
        
        
        #=======================================================================
        # #Hazard Event Rasters
        #=======================================================================
        #setup the list widget and add some special methods
        lv = self.listView_HZ_hrlay 
        bind_layersListWidget(lv, log, iface=self.iface,layerType=QgsMapLayer.RasterLayer)
        
        #connect standard hazars selection buttons
        self.pushButton_HZ_hrlay_selectAll.clicked.connect(lv.check_all)
        self.pushButton_HZ_hrlay_selectVis.clicked.connect(lv.select_visible)
        self.pushButton_HZ_hrlay_canvas.clicked.connect(lv.select_canvas)
        self.pushButton_HZ_hrlay_clear.clicked.connect(lv.clear_checks)
        self.pushButton_HZ_refresh.clicked.connect(lambda x: lv.populate_layers())
        
        #TODO: add a button to select all layers matching some string (e.g., 'haz')
        
        lv.populate_layers() #do an intial popluation.
        
        #bind some methods to the tableWidget_HZ_eventMeta
        bind_tableWidget(self.tableWidget_HZ_eventMeta, self.logger, iface=self.iface,
                         widget_type_d=eventMeta_control_d,
                         )
        

            
 
        
        self.pushButton_HZ_hrlay_load.clicked.connect(self.load_selected_rasters_to_eventMeta_widget)
        
            #connect loading into the event metadata view
    def load_selected_rasters_to_eventMeta_widget(self):
 
        #retrieve the selected layers from teh above table
        layers_d = self.listView_HZ_hrlay.get_selected_layers()
        
        #use the layer names and the eventMeta_df_template to build a new dataframe
        eventMeta_df = hazDB_schema_d['05_haz_events'].copy()
        eventMeta_df['event_name'] = layers_d.keys()
        eventMeta_df['layer_id'] = [layer.id() for layer in layers_d.values()]
        eventMeta_df['layer_fp'] = [layer.source() for layer in layers_d.values()]
        eventMeta_df['prob'] = 0.0 #probability]]    
        
        assert_df_matches_projDB_schema('05_haz_events', eventMeta_df)        
        
        #load this dataframe into the table widget
        self.tableWidget_HZ_eventMeta.set_df_to_QTableWidget_spinbox(eventMeta_df)
        
    
    def xxx_create_new_hazDB(self, fp, overwrite=True):
        """create a new hazard database file
        
        export?"""
        log = self.logger.getChild('_create_new_hazDB')
        
        #file check
        if os.path.exists(fp):
            log.warning(f'specified hazard database already exists overwrite={overwrite}')
            if overwrite:
                os.remove(fp)
            else:
                raise FileExistsError(f'specified hazard database already exists and overwrite is not set')
                
        
        log.debug(f'creating new hazard database at\n    {fp}')
        
        #=======================================================================
        # create the database tables
        #=======================================================================
        df_d = dict()
        table_name='04_haz_meta'
        df_d[table_name] = pd.read_csv(hazDB_meta_template_fp)
        
        
        table_name='05_haz_events'
        df_d[table_name] = hazDB_schema_d[table_name].copy()
        #===================================================================
        # build the database
        #===================================================================
        with sqlite3.connect(fp) as conn:
            #create the tables
            for table_name, df in df_d.items():
                df_to_sql(df, table_name, conn, if_exists='replace')
 
                
            #check the database
            assert_hazDB_conn(conn)
            
        log.info(f'created new hazard database at\n    {fp}')
        
        self._save_haz_ui_to_hazDB(hazDB_fp=fp)
        
        return
        
    def xxx_save_haz_ui_to_hazDB(self, *args, hazDB_fp=None, projDB_fp=None):
        """save the current UI state to the hazard database
        
        export button?"""
        #=======================================================================
        # defaults
        #=======================================================================
        log = self.logger.getChild('_save_haz_ui_to_hazDB')
        if hazDB_fp is None:
            hazDB_fp = self.lineEdit_HZ_hazDB_fp.text()
            
        if projDB_fp is None:
            projDB_fp = self.lineEdit_PS_projDB_fp.text()
            
        if hazDB_fp == '' or hazDB_fp is None:
            raise ValueError('no hazard database file path specified')
        
        assert_hazDB_fp(hazDB_fp)
        
        log.debug(f'saving UI to hazard database at\n    {hazDB_fp}')
        #=======================================================================
        # open and load
        #=======================================================================
        df_d=dict()
        with sqlite3.connect(hazDB_fp) as conn:
            
            #===================================================================
            # update hazard meta
            #===================================================================
            table_name='04_haz_meta'
            df_d[table_name] = sql_to_df(table_name, conn)
 
            
            d = self._get_ui_state_from_df_template(df_d[table_name])
            df_d[table_name]['value'] = pd.Series(d)
            
            #===================================================================
            # update the hazard events table
            #===================================================================
            table_name='05_haz_events'
            """always starting fresh"""
 
            
            #read the dataframe from the table widget
            df_raw = self.tableWidget_HZ_eventMeta.get_df_from_QTableWidget()
            if len(df_raw)>0:
                df_d[table_name] = df_raw.rename(
                    columns={v['label']:k for k,v in eventMeta_control_d.items()})
                
 
                #clean up the extraction
                df_d[table_name] = df_d[table_name].replace('', pd.NA).astype(hazDB_schema_d[table_name].dtypes.to_dict())
                
                assert_eventMeta_df(df_d[table_name])
                
                            #warn on empties
                for columnName, col in df_d[table_name].items():
                    if columnName in ['metadata']:continue
                    if col.isna().any():
                        log.warning(f'empty values in column \'{columnName}\'')
                    
            else:
                log.warning(f'no hazard event data entered')
 
 
            #===================================================================
            # #write the tables
            #===================================================================
            for k, df in df_d.items():
                assert k in hazDB_schema_d.keys(), k
                df_to_sql(df, k, conn, if_exists='replace')
 
                log.debug(f'    updated hazDB table \'{k}\' w/ {df.shape}')
                
            assert_hazDB_conn(conn)
            
            #close the connection
        log.debug(f'finished saving UI to hazard database at\n    {hazDB_fp}')
        #=======================================================================
        # update the project database as well
        #=======================================================================
        """mirroring the hazard tables inside the project database
            gives us a more portalbe project database
            makes accessing the full table stack easier
            
        users can still load a different hazard database, then load this into the project database
        """
        if not (projDB_fp is None or projDB_fp == ''):
            log.debug(f'updating project database w/ hazard tables \n    {projDB_fp}')
            with sqlite3.connect(projDB_fp) as conn:
                for k, df in df_d.items():
                    assert k in project_db_schema_d.keys(), k
                    df_to_sql(df, k, conn, if_exists='replace')
 
                    log.debug(f'    updated projDB table \'{k}\' w/ {df.shape}')
                    
                assert_projDB_conn(conn)
        else:
            log.warning(f'no project database found... hazard tables not mirrored')
        
        #close sqlite

        log.push(f'UI state saved to hazards database')
            
        return
    
    def _import_hazDB(self, hazDB_fp, logger=None):
        """load the UI state from a hazard database file"""
        raise NotImplementedError('need to add the import logic')
        #=======================================================================
        # defautls
        #=======================================================================
        if logger is None: logger=self.logger
        log = logger.getChild('_load_hazDB')
        if hazDB_fp is None:
            hazDB_fp = self.get_hazDB_fp()
            
        log.info(f'loading from hazard database at\n    {hazDB_fp}')
        #=======================================================================
        # load the tables
        #=======================================================================
        haz_meta_df, haz_events_df = self._hazDB_get_tables('04_haz_meta', '05_haz_events', hazDB_fp=hazDB_fp)
        
        
        #set UI parameter state
        self._get_ui_state_from_df_template(haz_meta_df, logger=log)
        
        #set the event metadata widget
        self.tableWidget_HZ_eventMeta.set_df_to_QTableWidget_spinbox(haz_events_df)
        
        log.debug(f'finished loading from hazard database at\n    {hazDB_fp}')
            
            
    
    def _hazDB_get_tables(self, table_names, hazDB_fp=None):
        """Convenience wrapper to get multiple tables as DataFrames.
    
        Parameters:
        *table_names: Variable number of table names (str) to fetch.
 
        """
        if hazDB_fp is None:
            hazDB_fp = self.lineEdit_HZ_hazDB_fp.text()
        assert isinstance(table_names, (list, tuple)), type(table_names)
        
        assert_hazDB_fp(hazDB_fp)
        
        with sqlite3.connect(hazDB_fp) as conn:
            dfs = tuple(sql_to_df(name, conn) for name in table_names)
             
    
        return dfs
    
    
    def get_haz_meta_df(self):
        """build the meta_df from the ui state"""
        
        #load the template
        df  = hazDB_schema_d['04_haz_meta'].copy()        
 
        #use to retrieve ui values
        d = self._get_ui_state_from_df_template(df)
        df['value'] = pd.Series(d)
        
        """
        view(df_template)
        """
        
        return df
    
    def get_haz_events_df(self, logger=None):
        #=======================================================================
        # defaults
        #=======================================================================
        if logger is None: logger=self.logger
        log = logger.getChild('get_haz_events_df')
        
        #=======================================================================
        # #read the dataframe from the table widget
        #=======================================================================
        df_raw = self.tableWidget_HZ_eventMeta.get_df_from_QTableWidget()
        
        log.debug(f'raw event metadata dataframe\n{df_raw.shape}')
        
        #=======================================================================
        # process
        #=======================================================================
        if len(df_raw)>0:
            df = df_raw.rename(
                columns={v['label']:k for k,v in eventMeta_control_d.items()})
            
        
            #clean up the extraction
            template_df = get_template_df('05_haz_events')
            
            df = df.replace('', pd.NA).astype(template_df.dtypes)
            

            for columnName, col in df.items():
                if columnName in ['metadata']:continue
                if col.isna().any():
                    log.warning(f'empty values in column \'{columnName}\'')
                
        else:
            log.warning(f'no hazard event data entered')
            df=None
            
        return df
    
    def get_haz_rlay_d(self):
        """get the selected hazard rasters
        
        here we simply retrieve teh selected rasters from the top panel
        these should be checked against the eventMeta table widget prior to use
        """
        try:
            return self.listView_HZ_hrlay.get_selected_layers()
    
        except Exception as e:
            raise IOError(f'failed to retrieve selected hazard rasters w/:\n    {e}')
    
 
            
            
            
            
class Main_dialog_modelSuite(object):
    """methods for dealing with the model suite and models""" 
    # reference container for identifying dynamically added widgets
    modelSuite_widget_type_d = {
        'label_mod_modelid': QLabel,
        'label_mod_asset': QLabel,
        'label_mod_consq': QLabel,
        'label_mod_status': QLabel,
        'progressBar_mod': QProgressBar,
        'pushButton_mod_run': QPushButton,
        'pushButton_mod_config': QPushButton,
        'pushButton_mod_plus': QPushButton,
        'pushButton_mod_minus': QPushButton
    }
    
    def _connect_slots_modelSuite(self, log):
        
        #inint the model config dialog
        #self.Model_config_dialog = Model_config_dialog(self.iface, parent=self, logger=self.logger)
        
        self.pushButton_MS_clear.clicked.connect(self._clear_all_models)
        
        
        #=======================================================================
        # #create an initial model suite dialog in each category
        #=======================================================================
        def create_modelSuite_templates():
            #check that the model suites have been cleared
            assert len(self.model_index_d)==0, f'must clearn model suite before creating templates'
 
            
            # Loop through each group box, and load the model template into it.
 
            for category_code, d in consequence_category_d.items():
                gb = getattr(self, d['boxName'])
 
                # Create a new layout for the group box if it doesn't have one
                if gb.layout() is None:
                    gb.setLayout(QtWidgets.QVBoxLayout())
            
                # Add the loaded widget to the group box's layout
                self._add_model(gb.layout(), category_code, logger=log)
     
     
            log.debug("populated model suite")
            
        self.pushButton_MS_createTemplates.clicked.connect(create_modelSuite_templates)
        
        #=======================================================================
        # initilzie the model config
        #=======================================================================
        """initlizing this once when the parent starts
        this slows down the parent startup, 
        but should be better for user experience as this dialog is called multiple times
        need to add some logic for reseting the dialog each time it is called by the ocnfigure button
        """
        self.Model_config_dialog = Model_config_dialog(self.iface, parent=self, logger=self.logger)
    
    def _add_model(self, layout, category_code,
                    logger=None,
                   projDB_fp=None,
                   check_projDB=False,
                   ):
        """start a model object, then add the template to the layout"""
        if logger is None: logger=self.logger.getChild('add_model')
        log = logger.getChild('add_model')
        if projDB_fp is None: projDB_fp = self.get_projDB_fp()
            
        assert not projDB_fp is None, 'must set a project database file before adding models'
        
        
        #=======================================================================
        # get index values
        #=======================================================================
        #retrieve the modelid
        if not category_code in self.model_index_d:
            self.model_index_d[category_code] = dict()
            
        modelid = len(self.model_index_d[category_code])
        
        modelName = f'{category_code}_{modelid}'
        
        log.debug(f'initiating model \'{modelName}\'')
        
        model = Model(
            parent=self,
            category_code=category_code, modelid=modelid, logger=self.logger)
        
        assert model.modelid==modelid, 'modelid mismatch'
        
        index_d = model.get_index_d()
        
        
        #=======================================================================
        # index consistency checks
        #=======================================================================
        assert not modelid in self.model_index_d[category_code], f'modelid already in index'
        
        #check model is not in the index
        
        if check_projDB:
            """ this can happen when we load a project database with models already in it"""
            assert model.get_model_index_ser() is None, f'model already in index'
 
    
            # Check for latent model tables and log details if any are found
        
            latent_tables = model.get_tables_all()
            if len(latent_tables) > 0:
                error_message = f'Found {len(latent_tables)} latent model tables: {list(latent_tables.keys())}. Possible bad DB cleanup.'
                #log.error(error_message)
                raise AssertionError(error_message)

        
        
        #=======================================================================
        # init on project database
        #=======================================================================
        """only adding an entry to the index and the parameter table
        other tables are added during run"""
            
        log.debug(f'creating model parameter table for \'{modelName}\'')
        df_d = dict()
        with sqlite3.connect(projDB_fp) as conn:
            
            #===================================================================
            # #add the parameter table
            #===================================================================
            table_name = model.get_table_names(['table_parameters'])[0]
            df_d[table_name] = projDB_schema_modelTables_d['table_parameters'].copy()
            
            #add the indexers            
            for k,v in index_d.items():
                df_d[table_name].loc[df_d[table_name]['varName']==k, 'value'] = str(v)
 
            
            df_to_sql(df_d[table_name], table_name, conn, if_exists='replace', 
                      template_prefix=model.template_prefix_str)

            
        log.debug(f'created parameter table for model \'{modelName}\'')
 
        #===================================================================
        # #add entry to model index
        #===================================================================
        self.update_model_index_dx(model, projDB_fp=projDB_fp, logger=log)
 
            
        #check it
        #=======================================================================
        # assert self.get_model_index_dx().loc[(modelid, category_code), 'status']=='initialized', \
        #     'failed to add model to index'
        #=======================================================================
        if check_projDB:
            assert model.get_table_names_all()==[table_name], 'model tabels were not added correctly'
 
 
        
        #=======================================================================
        # #setup the UI        
        #=======================================================================
        log.debug(f'adding model to category \'{category_code}\'')
        widget = load_model_widget_template() #load the model template
        layout.addWidget(widget) #add it to the widget
        
        
        #loop through each of the widget elements and give them a reference
        """because we add these dynamically, we need a way to lookup by model id"""
        widget_d = dict()
        for name, widget_type in self.modelSuite_widget_type_d.items():
            # Recursive search: findChild is recursive by default in PyQt.
            child_widget = widget.findChild(widget_type, name)            
            assert isinstance(child_widget, widget_type), f'failed to find widget: {name}'            
            
            widget_d[name] = {'name': name, 'widget': child_widget}
            

        
 
        #attach to the model worker
        """not sure about this.. might make cleaning up strange"""
        model.widget_d = widget_d
        model.widget_suite = widget
        
        #set labels
        self._update_model_widget_labels(model=model)
        
        #connect the buttons
        widget.pushButton_mod_run.clicked.connect(lambda : self._run_model(category_code, modelid))
        widget.pushButton_mod_config.clicked.connect(lambda : self._launch_config_ui(category_code, modelid))
        widget.pushButton_mod_minus.clicked.connect(lambda : self._remove_model(category_code, modelid))
        widget.pushButton_mod_plus.clicked.connect(lambda : self._add_model(layout, category_code))
        
 
 
        
        #=======================================================================
        # #add to the index
        #=======================================================================
 
        self.model_index_d[category_code][modelid] = model
        
        log.debug(f'added model \'{modelName}\' to category \'{category_code}\'')
        
        return model
        
    def _update_model_widget_labels(self, model=None):
        """update hte model suite widget witht he model labels"""
        
        if model is None:
            raise NotImplementedError('extract by index')
        
        #retrieve values from model index
        s = model.get_model_index_ser().fillna('')
 
        widget_d = model.widget_d
        
        widget_d['label_mod_modelid']['widget'].setText('%2d' % model.modelid)
        widget_d['label_mod_asset']['widget'].setText(s['asset_label'])
        widget_d['label_mod_consq']['widget'].setText(s['consq_label'])
        
        
        #=======================================================================
        # status
        #=======================================================================
        """status updates handled bymodel now"""
        #=======================================================================
        # widget_d['label_mod_status']['widget'].setText(s['status'])
        
        status = model.compute_status()
 
        if status == 'complete':
            widget_d['progressBar_mod']['widget'].setValue(100)
        else:
            widget_d['progressBar_mod']['widget'].setValue(0)

        
        
        
    def _launch_config_ui(self, category_code, modelid):
        """launch the configuration dialog"""
        log = self.logger.getChild('launch_config_ui')
        
        log.debug(f'user pushed model config for {category_code} {modelid}')
        #=======================================================================
        # retrival
        #=======================================================================
        #check ther eis a project database
        projDB_fp = self.get_projDB_fp()
        assert not projDB_fp is None, 'must set a project database file'
 

 
        #get this model
        model = self.model_index_d[category_code][modelid]
        
        dial = self.Model_config_dialog
        #check that the dialog is already closed
        assert not dial.isVisible(), 'dialog is already open!'
        
        
        log.info(f'launching model configuration dialog for {model.name}')
        #=======================================================================
        # #load the model into the dialog
        #=======================================================================
        dial.load_model(model, projDB_fp=projDB_fp)
 
        
        #launch teh dialog modally
        result = dial.exec_()
        
        #move teardown onto the child dialog for cleaner testing
        #dial.model=None #clear the model
        
    #===========================================================================
    # def _run_model(self, category_code, modelid):
    #     raise NotImplementedError('need to add the run logic')
    #===========================================================================
        
    def _remove_model(self, category_code, modelid, 
                      clear_projDB=True,
                      logger=None):
        """remove an individual model"""
        if logger is None: logger=self.logger
        log = logger.getChild(f'_remove_model_{category_code}_{modelid}')
        log.debug(f'clearing model {modelid} from category \'{category_code}\'')
        
        
        #retrieve the model
        model = self.model_index_d[category_code][modelid]
        
        
        #=======================================================================
        # #remove the widget
        #=======================================================================
        if model.widget_suite is not None:
            widget = model.widget_suite
 
 
            parent = widget.parentWidget()
            if parent is not None:
                layout = parent.layout()  # Get the parent's layout
                if layout is not None:
                    layout.removeWidget(widget)
            widget.setParent(None)   # Detach the widget from its parent
            widget.deleteLater()     # Schedule the widget for deletion           
            
            model.widget_suite = None
            
        #=======================================================================
        # #remove all the tables
        #=======================================================================
        if clear_projDB:
            #sometimes we dont want to touch the projectDatabase
            #model tables
            model_table_names_l = model.get_table_names_all()
            self.projDB_drop_tables(*model_table_names_l, logger=log)
            
            #remove entry from model index table
            dx = self.get_model_index_dx().drop(index=(modelid, category_code))
            self.projDB_set_tables({'03_model_suite_index':dx.reset_index()}, logger=log)
        
            
        
        #=======================================================================
        # #exit the model helper instance
        #=======================================================================
        try:
            model.__exit__(None, None, None)
        except Exception as e:
            log.debug(f'Error during __exit__ cleanup: {e}')
            
        # Remove the helper instance from the dictionary.
        del self.model_index_d[category_code][modelid]
        
        # If no models remain in this category, you can remove the category key as well.
        if not self.model_index_d[category_code]:
            del self.model_index_d[category_code]
        
        
    def _clear_all_models(self, *args, clear_projDB=True, logger=None):
        """clear all the models"""
        if logger is None: logger=self.logger
        log = logger.getChild('_clear_all_models')
        cnt=0
        log.debug('clearing all models')
        
        #=======================================================================
        # #loop through each model and close it
        #=======================================================================
        #collect the keys so we dont work on the index
        keys_d = dict()
        for category_code, d in self.model_index_d.items():
            keys_d[category_code] = list(d.keys())
        
        #look through and delete by index
        for category_code, modelid_l in keys_d.items():
            for modelid in modelid_l:
                try:
                    self._remove_model(category_code, modelid, logger=log, clear_projDB=clear_projDB)
                except Exception as e:
                    raise IOError(f'failed to clear model {category_code}_{modelid}: {e}')  
                cnt+=1
            
            
        
        #reset the index dictionary
        self.model_index_d = dict()
        
        #reset the model index table
        """no... each model removes its own row"""
        #table_name='03_model_suite_index'
        #self.projDB_set_tables({table_name:project_db_schema_d[table_name].copy()})
        
        
        
        
        #check
        if clear_projDB:
            model_index_dx = self.get_model_index_dx()
            assert len(model_index_dx)==0, f'failed to clear models: {len(model_index_dx)}'
        
        #clear garbage
        gc.collect()
        

 
        log.info(f'cleared {cnt} models')
        

        


            
            
class Main_dialog_projDB(object):
    """methods for dealing with the project database"""
    def get_projDB_fp(self):
        """get the project database file path and do some formatting and checks"""
        fp = self.lineEdit_PS_projDB_fp.text()
        if fp=='':
            fp = None
        
        if not fp is None:
            assert isinstance(fp, str)
            assert os.path.exists(fp), f'bad filepath for projDB: {fp}'
            
        return fp
        

    def projDB_get_tables(self, table_names, projDB_fp=None, result_as_dict=False, template_prefix=None):
        """Convenience wrapper to get multiple tables as DataFrames.
    
        Parameters:
        *table_names: Variable number of table names (str) to fetch.
        projDB_fp: Optional; path to the project database file. If None, it will use the value from self.lineEdit_PS_projDB_fp.text().
        result_as_dict: Optional; if True, returns a dictionary {name: df} instead of a tuple.
    
        Returns:
        If a single table name is passed, returns a DataFrame; otherwise, returns a tuple of DataFrames in the same order as table_names or a dictionary {name: df} if result_as_dict is True.
        """
        assert isinstance(table_names, list)
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
        
        assert isinstance(projDB_fp, str)
        assert os.path.exists(projDB_fp)
    
        with sqlite3.connect(projDB_fp) as conn:
            #assert_projDB_conn(conn)
 
            dfs = {name: sql_to_df(name, conn, template_prefix=template_prefix) for name in table_names}
    
        if result_as_dict:
            return dfs
        else:
            return list(dfs.values()) 
             

    

    def projDB_set_tables(self, df_d, projDB_fp=None, conn=None, logger=None, **kwargs):
        """Convenience wrapper to set multiple tables from DataFrames.
    
        Parameters:
        df_d: dict
            Dictionary of DataFrames to set in the project database.
        projDB_fp: Optional; path to the project database file. If None, it will use the value from self.lineEdit_PS_projDB_fp.text().
        conn: Optional; SQLite connection object. If None, a new connection will be created.
        """
        
        if logger is None: logger=self.logger
        log = logger.getChild('projDB_set_tables')
        
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
    

    
        #assert_projDB_fp(projDB_fp)
    
        # Check if conn is provided, if not, create a new connection
        close_conn = False
        if conn is None:
            conn = sqlite3.connect(projDB_fp)
            close_conn = True
    
        try:
            for k, df in df_d.items():
                df_to_sql(df, k, conn,  **kwargs)
                log.debug(f'    wrote table \'{k}\' w/ {df.shape}')
 #==============================================================================
 #                try:
 #                    #handling schema checks in the df_to_sql function
 # 
 #   #============================================================================
 #   #                  if k in project_db_schema_d.keys():
 #   #                      """this test happens before we re-cast the types and indicies"""
 #   #                      
 #   #                      assert_df_matches_projDB_schema(k, df, check_dtypes=False)
 #   # 
 #   #                  elif k.startswith('model_'):
 #   #                      pass
 #   #  
 #   #                  elif k.startswith('vfunc_'):
 #   #                      pass
 #   #  
 #   #                  else:
 #   #                      raise KeyError(f'bad table name: {k}')
 #   #============================================================================
 #    
 #                    df_to_sql(df, k, conn, if_exists='replace', **kwargs)
 #                    log.debug(f'    wrote table \'{k}\' w/ {df.shape}')
 # 
 #                except Exception as e:
 #                    raise IOError(f'failed to set table \'{k}\' to project database:\n     {e}') from None
 #==============================================================================
        finally:
            #assert_projDB_conn(conn)
            if close_conn:
                conn.close()
    
        log.debug(f'updated {list(df_d.keys())} tables in project database at\n    {projDB_fp}')

                
    def projDB_drop_tables(self, *table_names, projDB_fp=None, logger=None):
        """Convenience wrapper to drop multiple tables from the project database.
    
        Parameters:
        *table_names: Variable number of table names (str) to drop.
        projDB_fp: Optional; path to the project database file. If None, it will use the value from self.lineEdit_PS_projDB_fp.text().
        """
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
        if logger is None: logger=self.logger
        log = logger.getChild('projDB_drop_tables')
    
        assert_projDB_fp(projDB_fp)
    
 

        with sqlite3.connect(projDB_fp) as conn:
            for name in table_names:
                assert name in get_table_names(conn), name
                conn.execute(f'DROP TABLE IF EXISTS [{name}]')
        
                # Check if the table still exists
                if name in get_table_names(conn):
                    raise RuntimeError(f'Failed to drop table: {name}')
        
        log.debug(f'dropped {len(table_names)} tables from project database\n    {table_names}')
        
    def projDB_get_table_names_all(self, projDB_fp=None):
        """Convenience wrapper to get all table names from the project database.
    
        Parameters:
        projDB_fp: Optional; path to the project database file. If None, it will use the value from self.lineEdit_PS_projDB_fp.text().
    
        Returns:
        List of table names in the project database.
        """
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
    
        with sqlite3.connect(projDB_fp) as conn:
 
            return get_table_names(conn)

 
        

    def update_model_index_dx(self, model, **kwargs):
        """update the model index table with the model"""
        dx = self.get_model_index_dx()
        
        """
        view(dx)
        """
 
        
        #retrieve the parameters from teh models parameter table
        s = model.get_model_index_ser()
 
        
        #assert 'status' in s.index, 'missing status' #should always be present
        
        #update the dx (where teh column names match the param_s index
        dx.loc[(model.modelid, model.category_code), :] = s
        

        self.set_model_index_dx(dx, **kwargs) 
        
    def get_model_index_dx(self, **kwargs):
        df = self.projDB_get_tables(['03_model_suite_index'], **kwargs)[0]

        df['modelid'] = df['modelid'].astype(int)
        return df.set_index(['modelid', 'category_code'])
    
    def set_model_index_dx(self, dx, **kwargs):
        self.projDB_set_tables({'03_model_suite_index':dx.reset_index()}, **kwargs)
        """
        dx.reset_index().dtypes
        """
 
        
 
    
class Main_dialog(Main_dialog_projDB, Main_dialog_haz, Main_dialog_modelSuite, Main_dialog_dev,
                  QtWidgets.QDialog, FORM_CLASS):
    

    
 
    
    def __init__(self, parent=None,iface=None,debug_logger=None):
        """dialog for main CanFlood window
        
        
        Parameters
        ----------
        parent : QWidget
            parent widget
        iface : QgsInterface
            QGIS interface
            
        debug_logger : logging.Logger
            logger pytests
        """
        #not sure why the template passes parent here
        #super(Main_dialog, self).__init__(parent)
        super(Main_dialog, self).__init__()
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.parent=parent
        self.iface=iface 
        
        self.model_index_d = dict() #for tracking the model instances
        #{category_code:{modelid:Model}}
        
        #setup logger
        self.logger = plugLogger(
            self.iface, parent=self, statusQlab=self.progressText,debug_logger=debug_logger,
            log_nm='MD',
            )
        
        self.connect_slots()
        
        self.logger.debug('Main_dialog initialized')
        
    def connect_slots(self):
        """on launch of ui, populate and connect"""
 
        log = self.logger.getChild('connect_slots')
        log.debug('connecting slots')
        
        #=======================================================================
        # GEN=======================----------------
        #=======================================================================
        
        
        def close_dialog():
            self.logger.push(f'dialog reset')
            if not self.parent is None:
                self.parent.dlg=None
                self.parent.first_start=True #not ideal
            self.close()
        
        self.pushButton_close.clicked.connect(close_dialog)
        
        
        self.pushButton_save.clicked.connect(self._save_ui_to_projDB)
        
        
        """not using 
        self.cancel_pushButton.clicked.connect(self.action_cancel_process)"""
        
        from canflood2 import __version__
        self.label_version.setText(f'v{__version__}')
        #=======================================================================
        # WELCOME======================--------------
        #=======================================================================
        #=======================================================================
        # tutorial data
        #=======================================================================
        
        
        #populate the comboBox
        self.comboBox_tut_names.addItems(
            [tutorial_fancy_names_d[k] for k in tutorial_data_lib.keys()]
            )
        #reverr to index -1
        self.comboBox_tut_names.setCurrentIndex(-1)
        
        #connect the runner button
        self.pushButton_tut_load.clicked.connect(self._load_tutorial_to_ui)
        
        #disable the pushbutton until the comboBox is set
        self.pushButton_tut_load.setEnabled(False)
        
        self.comboBox_tut_names.currentIndexChanged.connect(
            lambda : self.pushButton_tut_load.setEnabled(True))
        
        #=======================================================================
        # Project Setup tab========================-----------
        #=======================================================================
        
        #=======================================================================
        # project database file
        #=======================================================================
        
        def _new_projDB():
            """wrapper for the New Project Database button"""
 
            
            filename = None
            try:
                filename, _ = QFileDialog.getSaveFileName(
                    self,  # Parent widget (your dialog)
                    "Save project database (sqlite) file",  # Dialog title
                    home_dir,  # Initial directory (optional, use current working dir by default)
                    fileDialog_filter_str
                )
            except Exception as e:
                log.warning(f'error on file dialog: {e}')
                
            if filename:
                self.lineEdit_PS_projDB_fp.setText(filename)
                self._create_new_projDB(filename)
                self.pushButton_save.setEnabled(True)
                log.push(f'created new project database at\n    {filename}')
                
        self.pushButton_PS_projDB_new.clicked.connect(_new_projDB)
            
            
            
        def load_project_database_ui():
            log.debug('create_new_project_database_ui')
 
            filename, _ = QFileDialog.getOpenFileName(
                self,  # Parent widget (your dialog)
                "Open project database (sqlite) file",  # Dialog title
                home_dir,  # Initial directory (optional, use current working dir by default)
                fileDialog_filter_str  # Example file filters
                )
            if filename:
                self.lineEdit_PS_projDB_fp.setText(filename) 
                self._load_projDB_to_ui()
                
                #activate the save button
                self.pushButton_save.setEnabled(True)            
 
        self.pushButton_PS_projDB_load.clicked.connect(load_project_database_ui)
        

                
        
        
        #=======================================================================
        # MapLayerComboBox
        #=======================================================================
        bind_MapLayerComboBox(self.comboBox_aoi, iface=self.iface, layerType=QgsMapLayerProxyModel.PolygonLayer)

        bind_MapLayerComboBox(self.comboBox_dem, iface=self.iface, layerType=QgsMapLayerProxyModel.RasterLayer)
 
        
        #=======================================================================
        # Hazard scenario tab------------
        #=======================================================================
        self._connect_slots_haz(log)
        
        #=======================================================================
        # Model Suite---------
        #=======================================================================
        self._connect_slots_modelSuite(log)
 
        
        #=======================================================================
        # wrap
        #=======================================================================
        log.debug('slots connected')
        



    
    def _create_new_projDB(self, fp, overwrite=True):
        """create a new project database file"""
        log = self.logger.getChild('_create_new_projDB')
        
        #file check
        if os.path.exists(fp):
            if overwrite:
                log.warning(f'specified project database already exists and will be overwritten')
                os.remove(fp)
            else:
                raise FileExistsError(f'specified project database already exists and overwrite is not set')
            
        df_d = dict()
        #=======================================================================
        # #build the project metadata
        #=======================================================================
        table_name='01_project_meta'
        d = _get_proj_meta_d(log)
        d.update(dict(function_name='_create_new_projDB', misc=''))
        
        
        df_d[table_name] = pd.DataFrame(d)
        
        assert_df_matches_projDB_schema(table_name, df_d[table_name])
        
        """
        table
        tabel
        """
        #=======================================================================
        # #build the project parameters
        #=======================================================================
        table_name='02_project_parameters'
        df_d[table_name] = project_db_schema_d[table_name].copy()
        
        #check the widget names match
        for widgetName in df_d[table_name]['widgetName']:
            assert hasattr(self, widgetName), f'widgetName not found: {widgetName}'
        
        assert_df_matches_projDB_schema(table_name, df_d[table_name])
        #=======================================================================
        # model suite template
        #=======================================================================
        """this will be over-written in _save_ui_to_projDB
        but we need it here to pass the check
        """
        table_name='03_model_suite_index'
        df_d[table_name] = project_db_schema_d[table_name].copy()
        
        assert_df_matches_projDB_schema(table_name, df_d[table_name])
        #=======================================================================
        # hazard tables
        #=======================================================================
        #hazard meta
        table_name='04_haz_meta'
        df_d[table_name] = project_db_schema_d[table_name].copy()
        
        assert_df_matches_projDB_schema(table_name, df_d[table_name])
        
        #others
        for k, v in hazDB_schema_d.items():
            if not k==table_name:
                assert isinstance(v, pd.DataFrame), k
                df_d[k] = v.copy()
                
                assert_df_matches_projDB_schema(k, df_d[k])
                
                
        #=======================================================================
        # remainers
        #=======================================================================
        for k, v in project_db_schema_d.items():
            if not k in df_d.keys():
                df_d[k] = v.copy()
                assert_df_matches_projDB_schema(k, df_d[k])
        
        #=======================================================================
        # #build/write to the database
        #=======================================================================
        log.debug(f'init project SQLite db at\n    {fp}')
        with sqlite3.connect(fp) as conn:
            for k, df in df_d.items():                
                df_to_sql(df, k, conn, if_exists='replace')
 
                
                
        assert_projDB_fp(fp)
                
        log.info(f'created new project database w/ {len(df_d)} tables at\n    {fp}')
        
        #=======================================================================
        # wrap
        #=======================================================================
        """no.. lets wait til the user hits save
        self._save_ui_to_projDB(projDB_fp=fp)"""
        
        

    def _get_ui_state_from_df_template(self, df, logger=None):
        """take a dataframe with widget name columns and return a dictionary of widget values
        
        Parameters
        ----------
        df : pd.DataFrame
            columns: 'widgetName'
        """
        #=======================================================================
        # defautls
        #=======================================================================
        if logger is None: logger=self.logger
        log = logger.getChild('_get_ui_state_from_df_template')
        
        d = dict()
        for i, row in df.iterrows():
 
            widgetName = row['widgetName']
            #get the widget
            if not hasattr(self, widgetName):
                raise AttributeError(f'widgetName not found: {widgetName}')
            
            widget = getattr(self, widgetName)
            #retrieve value from widget
            if isinstance(widget, QtWidgets.QLineEdit):
                v = widget.text()
            elif isinstance(widget, QgsMapLayerComboBox):
                v, _ = get_layer_info_from_combobox(widget) #using names
            elif isinstance(widget, QtWidgets.QComboBox):
                v = widget.currentText()
            elif isinstance(widget, QtWidgets.QRadioButton):
                v = widget.isChecked()                
            else:
                raise NotImplementedError(f'widget type not implemented: {widget}')
            if (not v is None) and (v != ''):
                d[i] = v
            else:
                d[i] = np.nan
                
        #check the indicides match
 
        if not df.index.equals(pd.Series(d).index):
            raise ValueError("Indexes do not match")
        
        #=======================================================================
        # wrap
        #=======================================================================
        log.debug(f'set {len(d)} widget values from df')

        return d

    def _save_ui_to_projDB(self, *args, projDB_fp=None):
        """save the current UI state to the projDB
        
        the save button is on all tabs, so the user will expect this to dave all ui elements
        first we save the hazDB, then the project (which mirrors the hazDB)
        """
        #=======================================================================
        # defaults
        #=======================================================================
        log = self.logger.getChild('_save_ui_to_projDB')
        
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
            
        assert not projDB_fp is None, 'must set a project database file before saving'
        
 
 

        #=======================================================================
        # project database
        #=======================================================================        
        assert_projDB_fp(projDB_fp)
        log.debug(f'saving UI to project database at\n    {projDB_fp}')
        
        
        df_d=dict()
        with sqlite3.connect(projDB_fp) as conn:

            
            #===================================================================
            # update project metadata
            #===================================================================
            table_name='01_project_meta'
            d = _get_proj_meta_d(log)
            d.update(dict(function_name='_save_ui_to_projDB', misc=''))
            df_d[table_name] = pd.DataFrame(d)
            
            #===================================================================
            # #update the project parameters
            #===================================================================
            table_name='02_project_parameters'
            df_d[table_name] = sql_to_df(table_name, conn)
            #df_d[table_name] = pd.read_sql('SELECT * FROM [{}]'.format(table_name), conn)
            
            d = self._get_ui_state_from_df_template(df_d[table_name]) 
            
                        
            df_d[table_name]['value'] = pd.Series(d)
 
            
            
            #===================================================================
            # update the model suite index
            #===================================================================
            table_name='03_model_suite_index'
 
            blank_df = project_db_schema_d[table_name].copy()
 
            d=dict()
 
        
            for category_code, modelid_d in self.model_index_d.items():
 
                for modelid, wrkr in modelid_d.items():
                    raise NotImplementedError('use update_model_index_dx')
                    #add the model
                    s = wrkr.get_model_index_ser()
                    d[s.name] = s
            
            # Convert the dictionary to a DataFrame and concatenate with the blank DataFrame
            result_df = pd.concat([blank_df, pd.DataFrame(d).T], ignore_index=True)
            
            # Reindex the result DataFrame to match the blank DataFrame's columns
            df_d[table_name] = result_df.reindex(columns=blank_df.columns).astype(blank_df.dtypes.to_dict())
            
 
            #===================================================================
            # hazard tables
            #===================================================================
            table_name= '04_haz_meta'
            df_d[table_name] = self.get_haz_meta_df()
            
            table_name= '05_haz_events'
            haz_events_df = self.get_haz_events_df(logger=log)
            if not haz_events_df is None:
                df_d[table_name] = haz_events_df
 
            
            #===================================================================
            # write all the tables
            #===================================================================
            for k, df in df_d.items():
                assert k in project_db_schema_d.keys(), k
                df_to_sql(df, k, conn, if_exists='replace')
 
                log.debug(f'updated table \'{k}\' w/ {df.shape}')
                
        #close sqlite
        log.debug(f'updated {len(df_d)} tables in project database at\n    {projDB_fp}')
        log.push(f'UI state saved to project database')
            
        return
    
    def _load_projDB_to_ui(self, projDB_fp=None):
        """load an existing project database file
        
        this does not 'load' QgsMapLayers, but attempts to select them by name
        """
        log = self.logger.getChild('_load_projDB_to_ui')
        
        if projDB_fp is None:
            projDB_fp = self.get_projDB_fp()
 
 
        assert not projDB_fp is None or projDB_fp=='', 'no project database file path specified'
        log.debug(f'loading project database from\n    {projDB_fp}')
        
        
        assert_projDB_fp(projDB_fp, check_consistency=True)
        
 
            
        #=======================================================================
        # set the ui state from the project parameters
        #=======================================================================
        """loads dem and aoi as well"""
        table_name='02_project_parameters'
        df_raw = self.projDB_get_tables([table_name], projDB_fp=projDB_fp)[0]
        s = df_raw.dropna(subset=['widgetName', 'value']).set_index('widgetName')['value']
 
        if len(s)>0:
            log.debug(f'loading {len(s)} project parameters')
            for widgetName, value in s.items():
     
                #get the widget
                try:
                    widget = getattr(self, widgetName)                
                    set_widget_value(widget, value)
                except Exception as e:
                    raise ValueError(f'failed to set widget \'{widgetName}\' to \'{value}\': \n    {e}')
                    log.error(f'failed to set widget \'{widgetName}\' to \'{value}\': \n'+\
                               f'    {e}\nprojDB may be out of sync')
                
        else:
            log.warning(f'no project parameters found in projDB')
        
 
        #=======================================================================
        # load hazard data
        #=======================================================================
        log.debug('loading hazard data')
        table_name='05_haz_events'
        haz_events_df = self.projDB_get_tables([table_name], projDB_fp=projDB_fp)[0]
        """
        view(haz_events_df)
        """
        #refresh the raster window
        self.listView_HZ_hrlay.populate_layers()
        
        #check that these events are loaded onto the project
        haz_rlay_d = dict()
        for _, row in haz_events_df.iterrows():
            layer_match = get_unique_layer_by_name(row['event_name'], layer_type=QgsRasterLayer)
            if layer_match is None:
                log.warning(f'failed to find matching raster for: {row["event_name"]}')
            
            haz_rlay_d[row['event_name']] = layer_match
        
        #select these
        """later, we assert that the selection matches the event meta table widget"""
        self.listView_HZ_hrlay.check_byName([layer.name() for layer in haz_rlay_d.values()])
        
        #load the event meta onto the widget
        self.tableWidget_HZ_eventMeta.set_df_to_QTableWidget_spinbox(haz_events_df)  
                
        #=======================================================================
        # set the model suite
        #=======================================================================
        log.debug('loading model suite')
        #clear the model suite
        self._clear_all_models(clear_projDB=False, logger=log)
        
        model_index_dx = self.get_model_index_dx(projDB_fp=projDB_fp)
        
        if len(model_index_dx)>0:
            log.debug(f'loading {len(model_index_dx)} models')
            cnt=0
            for (modelid, category_code) , row in model_index_dx.iterrows():
 
                #get the groupbox
                params = consequence_category_d[category_code]
                gb = getattr(self, params['boxName'])                
                
                self._add_model(gb.layout(), category_code, logger=log)
                
                #check the modelid was added
                assert modelid in self.model_index_d[category_code], f'failed to add model {modelid}'
                cnt+=1
            
            log.info(f'loaded {cnt} models from project database')
                
        else:
            log.warning(f'no models found in projDB')
 
        #=======================================================================
        # wrap
        #=======================================================================
        log.push(f'loaded project from {os.path.basename(projDB_fp)}')
        
        return 
    
    
    
    def get_dem_vlay(self):
        """get the DEM layer"""
        rlay = self.comboBox_dem.currentLayer()
        if not rlay is None:
            assert isinstance(rlay, QgsRasterLayer)
             
        return rlay
    

                

            
            

            
        
            
        
        
        
        
        
        
#===============================================================================
# helpers-----
#===============================================================================


        
 
    
    
# Load the widget from the .ui file
def load_model_widget_template(
    model_template_ui = os.path.join(os.path.dirname(__file__), 'canflood2_model_widget.ui'), 
    parent=None):
    """load the model widget template"""
    assert os.path.exists(model_template_ui), f'bad model_template_ui: {model_template_ui}'
    widget = QtWidgets.QWidget(parent)
    uic.loadUi(model_template_ui, widget)
    return widget

# Path to the model template UI file
def extract_gropubox_codes(input_string):
    """
    Extracts 'c1' and the remaining text from the input string.

    Parameters:
    input_string (str): The input string in the format '[c1] remaining text'.

    Returns:
    tuple: A tuple containing 'c1' and the remaining text.
    """
    pattern = r'\[(.*?)\]\s*(.*)'
    match = re.match(pattern, input_string)

    if match:
        c1 = match.group(1)
        remaining_text = match.group(2)
        return c1, remaining_text
    else:
        return None, None
        
